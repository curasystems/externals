/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is part of dcm4che, an implementation of DICOM(TM) in
 * Java(TM), hosted at http://sourceforge.net/projects/dcm4che.
 *
 * The Initial Developer of the Original Code is
 * Gunter Zeilinger, Huetteldorferstr. 24/10, 1150 Vienna/Austria/Europe.
 * Portions created by the Initial Developer are Copyright (C) 2002-2005
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 * See listed authors below.
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */
package org.dcm4che2.imageioimpl.plugins.dcm;

import static org.junit.Assert.fail;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;

import javax.imageio.ImageIO;
import javax.imageio.stream.ImageInputStream;

import org.dcm4che2.imageio.plugins.dcm.DicomImageReadParam;
import org.junit.Test;

/**
 * Tests for the image reader code. The tests are based on visual inspection.
 * Once the correct test result is found, the SHA-1 hash for the test is
 * recorded. Whenever the output changes, the output should be regenerated by
 * enabling the FileOutputStream in
 * {@link #assertImage(String, String, int, String, DicomImageReadParam)}.
 * 
 * @author rick.riemer
 */
public class DicomImageReaderTest {

	/* The default, 512x512 SMPTE image */
	private static BufferedImage smpte;

	/**
	 * Tests the reading of a regular MR instance.
	 * Also tests pixel padding - avoids putting the pixel padding into the
	 * window level range.
	 */
	@Test
	public void testReadMrAutoWindowing() throws Exception {
		assertImage("/misc/mr", 0, null);
	}

	/**
	 * Tests the reading of a regular CT instance, with windowing elements in
	 * it's meta data.
	 */
	@Test
	public void testReadCtNoAutoWindowing() throws Exception {
		DicomImageReadParam param = new DicomImageReadParam();
		param.setAutoWindowing(false);
		assertImage("/misc/ct", 0, null);
	}

	/**
	 * Tests the reading of a regular CT instance, with windowing elements in
	 * it's meta data, but with a custom Window Center and Window Width set on
	 * the reader parameters.
	 * <p>
	 * <em>Note for visual inspection: since we set the Window Width to a small
	 * value, the rendered output should be clearly distinct from
	 * {@link #testReadCtNoAutoWindowing()}.</em>
	 */
	@Test
	public void testReadCtApplyCustomWindow() throws Exception {
		// TODO 2007-11-23 rick.riemer Re-enable test once we know what the
		// expected output for this test should be.
		DicomImageReadParam param = new DicomImageReadParam();
		param.setAutoWindowing(false);
		param.setWindowCenter(10);
		param.setWindowWidth(100);

		assertImage("/misc/ct.dcm", "/misc/ct-customwindow", 0, param);
	}

	/**
	 * Tests the reading of an arbitrary frame from a multi-frame instance. In
	 * this case an Enhanced CT from the test set from <a
	 * href="ftp://medical.nema.org/MEDICAL/Dicom/Multiframe/">the DICOM
	 * standard FTP server</a>.
	 * <p>
	 * <em>NOTE for visual inspection: frame 1 should be returned, which is a front
	 * view of a chest. If you see a side view, you're looking at the wrong
	 * frame (0).</em>
	 */
//	public void testReadMultiframe() throws Exception {
//		assertImage("/misc/ct-multiframe.dcm", "/misc/ct-multiframe-frame2", 1,null);
//	}

	/**
	 * Tests the reading of a CR instance, with MONOCHROME1 photometric
	 * interpretation, with Window Center and Window With elements.
	 */
	@Test
	public void testReadMonochrome1() throws Exception {
		assertImage("/misc/cr-monochrome1", 0,null);
	}

	/**
	 * Tests the reading of a CR instance, with MONOCHROME1 photometric
	 * interpretation, <em>without</em> Window Center and Window With
	 * elements.
	 */
	@Test
	public void testReadMonochrome1NoWindow() throws Exception {
		assertImage("/misc/cr-monochrome1-nowindow", 0, null);
	}

	/**
	 * Tests the reading of a CR instance, with MONOCHROME1 photometric
	 * interpretation, <em>without</em> Window Center and Window With
	 * elements, but with a custom Window Center and Window Width set on the
	 * reader parameters.
	 * <p>
	 * <em>Note for visual inspection: since we set the Window Center and
	 * Window Width to the same values as the instance used in
	 * {@link #testReadMonochrome1()}, the output (and thus the hash) is
	 * expected to be the same.</em>
	 */
	@Test
	public void testReadMonochrome1ApplyCustomWindow() throws Exception {
		DicomImageReadParam param = new DicomImageReadParam();
		param.setAutoWindowing(false);
		param.setWindowCenter(10000);
		param.setWindowWidth(27000);

		assertImage("/misc/cr-monochrome1-nowindow.dcm",
				"/misc/cr-monochrome1-nowindow-customwindow", 0,param);
	}

	/** Reads the default SMPTE image - mlut_01.dcm */
	public static synchronized BufferedImage getSmpte() throws IOException {
		if (smpte != null)
			return smpte;
		smpte = ImageIO.read(DicomImageReaderTest.class
				.getResourceAsStream("/misc/smpte.png"));
		return smpte;
	}

	/** Reads the image from the given resource name */
	public static BufferedImage readDicomImage(String resourceLocation,
			int frameNumber, DicomImageReadParam param) throws IOException {
		DicomImageReaderSpi spi = new DicomImageReaderSpi();
		DicomImageReader reader = (DicomImageReader) spi
				.createReaderInstance(null);

		ImageInputStream iis = null;
		InputStream is = DicomImageReaderTest.class
				.getResourceAsStream(resourceLocation);
		iis = ImageIO.createImageInputStream(is);

		reader.setInput(iis, true);
		BufferedImage image = reader.read(frameNumber, param);
		return image;
	}

	/**
	 * Tests the reading of instances from the IHE MESA Modality LUT test cases.
	 * It is expected that the hashes for all output are the same.
	 * <p>
	 * <em>Note for visual inspection: all images should produce the same test
	 * pattern</em>.
	 */
	@Test
	public void testMLUT() throws Exception {
		boolean failed = false;
		DicomImageReadParam param = new DicomImageReadParam();
		param.setAutoWindowing(true);
		for (int i = 1; i <= 19; ++i) {
			int allowedDiff = 0;
			// The first image fails to be exact because the SMPTE test is a generated test and it was rounded off
			// incorrectly (down) instead of nearest for 1 region of 670 odd pixels.
			// The second test is lossy, as it is only 128 bits of encoding and the SMPTE is 256 bits.
			if( i==1 ) 
				allowedDiff=1;
			else if (i == 2)
				allowedDiff = 2;
			String imgNumber = String.format("%02d", Integer.valueOf(i));
			String baseName = "/imgconsistency/mlut_" + imgNumber;
			String fileName = baseName + ".dcm";
			System.out.println("Testing image " + fileName);
			BufferedImage img = readDicomImage(fileName, 0, null);
			ImageDiff diff = new ImageDiff(getSmpte(), img, "target/"+baseName,
					allowedDiff);
			if (diff.getMaxDiff() > allowedDiff) {
				failed = true;
				System.err.println("File "
								+ baseName
								+ ".dcm failed - see .txt file for differences - max diff "
								+ diff.getMaxDiff());
			}
		}
		if (failed) {
			fail("one or more MLUT instances failed. see stderr for details.");
		}
	}

	/**
	 * Tests the reading of instances from the IHE MESA Modality LUT test cases.
	 * It is expected that the hashes for all output are the same.
	 * <p>
	 * <em>Note for visual inspection: all images should produce the same test
	 * pattern</em>.
	 */
	@Test
	public void testVLUT() throws Exception {
		boolean failed = false;
		DicomImageReadParam param = new DicomImageReadParam();
		param.setAutoWindowing(true);
		// Don't test 11 - it is a completely different type of test.
		for (int i = 1; i <= 10; ++i) {
			// Allow for 1 pixel value differences to account for rounding differences.
			int allowedDiff = 1;
			// vlut_03 and 08 are only 50 distinct values - less than 6 bits
			if( i==3 ) allowedDiff=3;
			else if( i==8 ) allowedDiff=5;
			String imgNumber = String.format("%02d", Integer.valueOf(i));
			String baseName = "/imgconsistency/vlut_" + imgNumber;
			String fileName = baseName + ".dcm";
			System.out.println("Testing image " + fileName);
			BufferedImage img = readDicomImage(fileName, 0, null);
			ImageDiff diff = new ImageDiff(getSmpte(), img, "target/"+baseName,
					allowedDiff);
			if (diff.getMaxDiff() > allowedDiff) {
				failed = true;
				System.err
						.println("File "
								+ baseName
								+ ".dcm failed - see .txt file for differences - max diff "
								+ diff.getMaxDiff());
			}
		}
		if (failed) {
			fail("one or more VLUT instances failed. see stderr for details.");
		}
	}

	public void assertImage(String baseName, int frameNumber, DicomImageReadParam param) throws Exception {
		assertImage(baseName+".dcm",baseName, frameNumber, param);
	}
	
	public void assertImage(String resourceLocation, String baseName,
			int frameNumber, DicomImageReadParam param) throws Exception {
		BufferedImage dcm = readDicomImage(resourceLocation, frameNumber, param);
		BufferedImage comp = null;
		try {
			comp = ImageIO.read(DicomImageReaderTest.class
					.getResourceAsStream(baseName+".png"));
		}
		catch(Exception e) {
			File f = new File(baseName+".png");
			if( f.exists() ) f.delete();
			e.printStackTrace();
			fail("No image to compare against, wrote image to current dir.");
		}
		ImageDiff diff = new ImageDiff(comp,dcm,"target/"+baseName,0);
		if( diff.getMaxDiff()!=0 ) {
			fail("Maximum difference on "+baseName+" is supposed to be zero but is "+diff.getMaxDiff());
		}
	}
}
