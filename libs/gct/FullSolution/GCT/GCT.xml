<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GCT</name>
    </assembly>
    <members>
        <member name="T:GCT.Stack.AckReceiverWindow">
            <remarks>
            Counterpart of AckSenderWindow.
            Every message received is ACK'ed (even duplicates) and added to a hashmap
            keyed by seqno. The next seqno to be received is stored in <code>next_to_remove</code>. When a message with
            a seqno less than next_to_remove is received, it will be discarded. The <code>remove()</code> method removes
            and returns a message whose seqno is equal to next_to_remove, or null if not found.
            </remarks>
            <summary>
            Stores messages that have been received and acknowledged.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Stack.AckReceiverWindow.initial_seqno">
            <summary>Sequence number of the first expected message</summary>
        </member>
        <member name="F:GCT.Stack.AckReceiverWindow.next_to_remove">
            <summary>Sequence number of the next message to be delivered</summary>
        </member>
        <member name="F:GCT.Stack.AckReceiverWindow.msgs">
            <summary>Collection of messages received</summary>
        </member>
        <member name="M:GCT.Stack.AckReceiverWindow.#ctor(System.Int64)">
            <summary>
            AckReceiverWindow Constructor
            </summary>
            <param name="initial_seqno">Sequence number to start from.</param>
        </member>
        <member name="M:GCT.Stack.AckReceiverWindow.add(System.Int64,GCT.Message)">
            <summary>
            Adds a message
            </summary>
            <param name="seqno">The sequence num of the message</param>
            <param name="msg">The message to add as received</param>
        </member>
        <member name="M:GCT.Stack.AckReceiverWindow.remove">
            <summary>
            Removes the next received message. Will only return a <c>Message</c> if all message before it 
            have been received.
            </summary>
            <returns>The next message</returns>
        </member>
        <member name="M:GCT.Stack.AckReceiverWindow.reset">
            <summary>
            Clears all received messages and resets the expectant sequence number.
            </summary>
        </member>
        <member name="M:GCT.Stack.AckReceiverWindow.ToString">
            <summary>
            Returns string representation of the object
            </summary>
            <returns>String representation of the object</returns>
        </member>
        <member name="T:GCT.Stack.AckSenderWindow">
            <remarks>
            Messages are added to the window keyed by seqno
            When an ACK is received, the corresponding message is removed. The Retransmitter
            continously iterates over the entries in the hashmap, retransmitting messages based on their
            creation time and an (increasing) timeout. When there are no more messages in the retransmission
            table left, the thread terminates. It will be re-activated when a new entry is added to the
            retransmission table.
            </remarks>
            <summary>
            ACK-based sliding window for a sender.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="T:GCT.Stack.Retransmitter.RetransmitCommand">
            <summary>
            Retransmit command used to retrieve missing messages
            </summary>
        </member>
        <member name="T:GCT.Stack.Retransmitter">
            <remarks>
            Maintains a pool of sequence numbers of messages that need to be retransmitted. Messages
            are aged and retransmission requests sent according to age (linear backoff used). If a
            TimeScheduler instance is given to the constructor, it will be used, otherwise Reransmitter
            will create its own. The retransmit timeouts have to be set first thing after creating an instance.
            The <code>add()</code> method adds a range of sequence numbers of messages to be retransmitted. The
            <code>remove()</code> method removes a sequence number again, cancelling retransmission requests for it.
            Whenever a message needs to be retransmitted, the <code>RetransmitCommand.retransmit()</code> method is called.
            It can be used e.g. by an ack-based scheme (e.g. AckSenderWindow) to retransmit a message to the receiver, or
            by a nak-based scheme to send a retransmission request to the sender of the missing message.
            </remarks>
            <summary>
            Maintains a pool of sequence numbers of messages that need to be retransmitted.
            <p><b>Author:</b> Chris Koiak, Bela Ban, John Giorgiadis</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.RETRANSMIT_TIMEOUTS">
            <summary>Default retransmit intervals (ms) - exponential approx.</summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.SUSPEND_TIMEOUT">
            <summary>Default retransmit thread suspend timeout (ms).</summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.sender">
            <summary>Address of the sender.</summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.msgs">
            <summary>List of all messages received</summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.cmd">
            <summary>Method called to retransmit</summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.retransmitter_owned">
            <summary>Signifys that the Scheduler is owned internally</summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.retransmitter">
            <summary></summary>
        </member>
        <member name="M:GCT.Stack.Retransmitter.#ctor(GCT.Address,GCT.Stack.Retransmitter.RetransmitCommand,GCT.Util.TimeScheduler)">
            <summary>
            Constructor: Create a new Retransmitter associated with the given sender address
            </summary>
            <param name="sender">The address from which retransmissions are expected or to which retransmissions are sent</param>
            <param name="cmd">The retransmission callback reference</param>
            <param name="sched">The retransmissions scheduler</param>
        </member>
        <member name="M:GCT.Stack.Retransmitter.#ctor(GCT.Address,GCT.Stack.Retransmitter.RetransmitCommand)">
            <summary>
            Constructor: Create a new Retransmitter associated with the given sender address
            </summary>
            <param name="sender">The address from which retransmissions are expected or to which retransmissions are sent</param>
            <param name="cmd">The retransmission callback reference</param>
        </member>
        <member name="M:GCT.Stack.Retransmitter.setRetransmitTimeouts(System.Int64[])">
            <summary>
            Sets the retransmission timeouts
            </summary>
            <param name="timeouts"></param>
        </member>
        <member name="M:GCT.Stack.Retransmitter.add(System.Int64,System.Int64)">
            <summary>
            Add the given range [first_seqno, last_seqno] in the list of
            entries eligible for retransmission. If first_seqno > last_seqno,
            then the range [last_seqno, first_seqno] is added instead
            </summary>
            <param name="first_seqno">First sequence number to retransmit</param>
            <param name="last_seqno">Last sequence number to retransmit</param>
        </member>
        <member name="M:GCT.Stack.Retransmitter.remove(System.Int64)">
            <summary>
            Remove the given sequence number from the list of seqnos eligible
            for retransmission. If there are no more seqno intervals in the
            respective entry, cancel the entry from the retransmission
            scheduler and remove it from the pending entries
            </summary>
            <param name="seqno">Sequence number to remove</param>
        </member>
        <member name="M:GCT.Stack.Retransmitter.reset">
            <summary>
            Reset the retransmitter: clear all msgs and cancel all the
            respective tasks
            </summary>
        </member>
        <member name="M:GCT.Stack.Retransmitter.stop">
            <remarks>
            If this retransmitter has been provided an externally managed
            scheduler, then just clear all msgs and the associated tasks, else
            stop the scheduler. In this case the method blocks until the
            scheduler's thread is dead. Only the owner of the scheduler should
            stop it.
            </remarks>
            <summary>
            Stop the retransmission and clear all pending msgs.
            </summary>
        </member>
        <member name="M:GCT.Stack.Retransmitter.init(GCT.Address,GCT.Stack.Retransmitter.RetransmitCommand,GCT.Util.TimeScheduler,System.Boolean)">
            <summary>
            Initialises this object
            </summary>
            <param name="sender">The address from which retransmissions are expected</param>
            <param name="cmd">The retransmission callback reference</param>
            <param name="sched">Schedular for retransmit tasks</param>
            <param name="sched_owned">sched_owned whether the scheduler parameter is owned by this object or is externally provided</param>
        </member>
        <member name="T:GCT.Stack.Retransmitter.RetransmitCommand">
            <summary>
            Retransmit command used to retrieve missing messages
            </summary>
        </member>
        <member name="M:GCT.Stack.Retransmitter.RetransmitCommand.retransmit(System.Int64,System.Int64,GCT.Address)">
            <summary>
            Get the missing messages between sequence numbers
            <code>first_seqno</code> and <code>last_seqno</code>. This can either be done by sending a
            retransmit message to destination <code>sender</code> (nak-based scheme), or by
            retransmitting the missing message(s) to <code>sender</code> (ack-based scheme).
            </summary>
            <param name="first_seqno">The sequence number of the first missing message</param>
            <param name="last_seqno">The sequence number of the last missing message</param>
            <param name="sender">The destination of the member to which the retransmit request will be sent</param>
        </member>
        <member name="T:GCT.Stack.Retransmitter.Task">
            <summary>
            The retransmit task executed by the scheduler in regular intervals
            </summary>
        </member>
        <member name="T:GCT.Util.TimeScheduler.Task">
            <summary>
            The interface that submitted tasks must implement
            </summary>
        </member>
        <member name="T:GCT.Util.TimeScheduler">
            <remarks>
            The scheduler supports varying scheduling intervals by asking the task
            every time for its next preferred scheduling interval. Scheduling can
            either be <i>fixed-delay</i> or <i>fixed-rate</i>. 
            In fixed-delay scheduling, the task's new schedule is calculated
            as:<br></br>
            new_schedule = time_task_starts + scheduling_interval
            <p>
            In fixed-rate scheduling, the next schedule is calculated as:<br></br>
            new_schedule = time_task_was_supposed_to_start + scheduling_interval</p>
            <p>
            The scheduler internally holds a queue of tasks sorted in ascending order
            according to their next execution time. A task is removed from the queue
            if it is cancelled, i.e. if <tt>TimeScheduler.Task.isCancelled()</tt>
            returns true.
            </p>
            <p>
            Initially, the scheduler is in <tt>SUSPEND</tt>ed mode, <tt>start()</tt>
            need not be called: if a task is added, the scheduler gets started
            automatically. Calling <tt>start()</tt> starts the scheduler if it's
            suspended or stopped else has no effect. Once <tt>stop()</tt> is called,
            added tasks will not restart it: <tt>start()</tt> has to be called to
            restart the scheduler.
            </p>
            </remarks>
            <summary>
            Fixed-delay and fixed-rate single thread scheduler
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Util.TimeScheduler.SUSPEND_INTERVAL">
            <summary>Default suspend interval (ms)</summary>
        </member>
        <member name="F:GCT.Util.TimeScheduler.TICK_INTERVAL">
            <remarks>
            Needed in case all tasks have been
            cancelled and we are still waiting on the schedule time of the task
            at the top
            </remarks>
            <summary>Regular wake-up intervals for scheduler</summary>
        </member>
        <member name="F:GCT.Util.TimeScheduler.RUN">
            <summary>State Constant</summary>
        </member>
        <member name="F:GCT.Util.TimeScheduler.SUSPEND">
            <summary>State Constant</summary>
        </member>
        <member name="F:GCT.Util.TimeScheduler.STOPPING">
            <summary>State Constant</summary>
        </member>
        <member name="F:GCT.Util.TimeScheduler.STOP">
            <summary>State Constant</summary>
        </member>
        <member name="F:GCT.Util.TimeScheduler.THREAD_NAME">
            <summary>TimeScheduler thread name</summary>
        </member>
        <member name="F:GCT.Util.TimeScheduler.thread">
            <summary>The scheduler thread</summary>
        </member>
        <member name="F:GCT.Util.TimeScheduler.thread_state">
            <summary>The thread's running state</summary>
        </member>
        <member name="F:GCT.Util.TimeScheduler.suspend_interval">
            <summary>Time that task queue is empty before suspending the scheduling thread</summary>
        </member>
        <member name="F:GCT.Util.TimeScheduler.queue">
            <summary>The task queue ordered according to task's next execution time</summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler._start">
            <summary>
            Set the thread state to running, create and start the thread
            </summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler._unsuspend">
            <summary>
            Restart the suspended thread
            </summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler._suspend">
            <summary>
            Set the thread state to suspended
            </summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler._stopping">
            <summary>
            Set the thread state to stopping
            </summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler._stop">
            <summary>
            Set the thread state to stopped
            </summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler._run">
            <remarks>
            Get the first task, if the running time hasn't been
            reached then wait a bit and retry. Else reschedule the task and then
            run it. 
            </remarks>
            <summary>
            If the task queue is empty, sleep until a task comes in or if slept
            for too long, suspend the thread.
            </summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler.#ctor(System.Int64)">
            <summary>
            Create a scheduler that executes tasks in dynamically adjustable
            intervals
            </summary>
            <param name="suspend_interval">
            The time that the scheduler will wait for
            at least one task to be placed in the task queue before suspending
            the scheduling thread
            </param>
        </member>
        <member name="M:GCT.Util.TimeScheduler.#ctor">
            <summary>
            Create a scheduler that executes tasks in dynamically adjustable
            intervals
            </summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler.add(GCT.Util.TimeScheduler.Task,System.Boolean)">
            <remarks>
            <b>Relative Scheduling</b>
            <tt>true</tt>:<br></br>
            Task is rescheduled relative to the last time it <i>actually</i>
            started execution
            <p>
            <tt>false</tt>:<br></br>
            Task is scheduled relative to its <i>last</i> execution schedule. This
            has the effect that the time between two consecutive executions of
            the task remains the same.
            </p>
            </remarks>
            <summary>
            Add a task for execution at adjustable intervals
            </summary>
            <param name="t">The task to execute</param>
            <param name="relative">Use relative scheduling</param>
        </member>
        <member name="M:GCT.Util.TimeScheduler.add(GCT.Util.TimeScheduler.Task)">
            <summary>
            Add a task for execution at adjustable intervals
            </summary>
            <param name="t">The task to execute</param>
        </member>
        <member name="M:GCT.Util.TimeScheduler.start">
            <summary>
            Start the scheduler, if it's suspended or stopped
            </summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler.stop">
            <summary>
            Stop the scheduler if it's running. Switch to stopped, if it's
            suspended. Clear the task queue.
            </summary>
        </member>
        <member name="T:GCT.Util.TimeScheduler.Task">
            <summary>
            The interface that submitted tasks must implement
            </summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler.Task.cancelled">
            <summary>
            Returns true if task is cancelled and shouldn't be scheduled again
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.Util.TimeScheduler.Task.nextInterval">
            <summary>
            The next schedule interval
            </summary>
            <returns>The next schedule interval</returns>
        </member>
        <member name="M:GCT.Util.TimeScheduler.Task.run">
            <summary>
            Execute the task
            </summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler.Task.getName">
            <summary>
            Gets the Task name
            </summary>
            <returns></returns>
        </member>
        <member name="T:GCT.Util.TimeScheduler.IntTask">
            <summary>
            Internal task class.
            </summary>
        </member>
        <member name="F:GCT.Util.TimeScheduler.IntTask.task">
            <summary>The user task</summary>
        </member>
        <member name="F:GCT.Util.TimeScheduler.IntTask.sched">
            <summary>The next execution time</summary>
        </member>
        <member name="F:GCT.Util.TimeScheduler.IntTask.relative">
            <summary>Whether this task is scheduled fixed-delay or fixed-rate</summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler.IntTask.#ctor(GCT.Util.TimeScheduler.Task,System.Int64,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="task">The task to schedule and execute</param>
            <param name="sched">The next schedule</param>
            <param name="relative">Whether scheduling for this task is soft or hard</param>
        </member>
        <member name="M:GCT.Util.TimeScheduler.IntTask.CompareTo(System.Object)">
            <remarks>
            If obj is not instance of <tt>IntTask</tt>, then return -1
            If obj is instance of <tt>IntTask</tt>, compare the
            contained tasks' next execution times. If these times are equal,
            then order them randomly <b>but</b> consistently!: return the diff
            of their <tt>hashcode()</tt> values
            </remarks>
            <summary>
            Compares two tasks with each other
            </summary>
            <param name="obj">Object to compare</param>
            <returns>An integer representation of the comparison</returns>
        </member>
        <member name="M:GCT.Util.TimeScheduler.IntTask.toString">
            <summary>
            Returns the name of the Task
            </summary>
            <returns>The name of the Task</returns>
        </member>
        <member name="T:GCT.Util.TimeScheduler.TaskQueue">
            <summary>
            The task queue used by the scheduler. Tasks are ordered in increasing
            order of their next execution time
            </summary>
        </member>
        <member name="F:GCT.Util.TimeScheduler.TaskQueue.list">
            <summary>Sorted list of <code>IntTask</code>s </summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler.TaskQueue.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler.TaskQueue.add(GCT.Util.TimeScheduler.IntTask)">
            <summary>
            Adds a Task to the list and reorders the queue.
            </summary>
            <param name="t">Task to add</param>
        </member>
        <member name="M:GCT.Util.TimeScheduler.TaskQueue.getFirst">
            <summary>
            Returns the first task in the list
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.Util.TimeScheduler.TaskQueue.removeFirst">
            <summary>
            Removes the first Task
            </summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler.TaskQueue.rescheduleFirst(System.Int64)">
            <summary>
            Reschedules the first element
            </summary>
            <param name="sched">Next execution time for the Task</param>
        </member>
        <member name="M:GCT.Util.TimeScheduler.TaskQueue.isEmpty">
            <summary>
            Checks if the list is empty
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.Util.TimeScheduler.TaskQueue.clear">
            <summary>
            Clears all Tasks
            </summary>
        </member>
        <member name="M:GCT.Util.TimeScheduler.TaskQueue.size">
            <summary>
            Returns the number of Tasks
            </summary>
            <returns></returns>
        </member>
        <member name="F:GCT.Stack.Retransmitter.Task.intervals">
            <summary>Intervals for transmission</summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.Task.stopped">
            <summary>Determines if Task is running</summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.Task.name">
            <summary>Name of task</summary>
        </member>
        <member name="M:GCT.Stack.Retransmitter.Task.#ctor(System.Int64[])">
            <summary>
            Constructor
            </summary>
            <param name="intervals">Intervals betweening sending message</param>
        </member>
        <member name="M:GCT.Stack.Retransmitter.Task.nextInterval">
            <summary>Returns the next interval</summary>
            <returns>The next interval</returns>
        </member>
        <member name="M:GCT.Stack.Retransmitter.Task.cancelled">
            <summary>Checks if Task is cancelled</summary>
            <returns>True, if Task is stopped</returns>
        </member>
        <member name="M:GCT.Stack.Retransmitter.Task.cancel">
            <summary>Cancels the Task</summary>
        </member>
        <member name="M:GCT.Stack.Retransmitter.Task.getName">
            <summary>Returns the name of the Task</summary>
            <returns>The name of the Task</returns>
        </member>
        <member name="M:GCT.Stack.Retransmitter.Task.run">
            <summary>Retransmits the messages</summary>
        </member>
        <member name="T:GCT.Stack.Retransmitter.Entry">
            <remarks>
            Groups are stored in a list as long[2] arrays of the each group's
            bounds. For speed and convenience, the lowest and highest bounds of
            all the groups in this entry are also stored separately
            <p>
            For Example: <br></br>
            - initial group: [5-34]
            - msg 12 is acknowledged, now the groups are: [5-11], [13-34]</p>
            </remarks>
            <summary>
            The entry associated with an initial group of missing messages
            with contiguous sequence numbers and with all its subgroups.
            </summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.Entry.low">
            <summary>Lowest sequence number in the Entry</summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.Entry.high">
            <summary>Highest sequence number in the Entry</summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.Entry.list">
            <summary>List of groups of sequence numbers</summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.Entry.initialSender">
            <summary>Sender of the messages</summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.Entry.retCmd">
            <summary>Method to call when retransmitting</summary>
        </member>
        <member name="M:GCT.Stack.Retransmitter.Entry.#ctor(System.Int64,System.Int64,System.Int64[],GCT.Address,GCT.Stack.Retransmitter.RetransmitCommand)">
            <summary>
            Constructor
            </summary>
            <param name="low">Lowest sequence number in the Entry</param>
            <param name="high">Highest sequence number in the Entry</param>
            <param name="intervals">Time intervals between retransmission</param>
            <param name="initialSender">Sender of the messages</param>
            <param name="retCmd">Method to call when retransmitting</param>
        </member>
        <member name="M:GCT.Stack.Retransmitter.Entry.remove(System.Int64)">
            <remarks>
            Remove the given seqno and resize or partition groups as
            necessary. The algorithm is as follows:
            <p>
            i. Find the group with low 'less than' seqno 'less than' high<br></br>
            ii. If seqno == low,<br></br>
            a. if low == high, then remove the group
            Adjust global low. If global low was pointing to the group
            deleted in the previous step, set it to point to the next group.
            If there is no next group, set global low to be higher than
            global high. This way the entry is invalidated and will be removed
            all together from the pending msgs and the task scheduler
            iii. If seqno == high, adjust high, adjust global high if this is
            the group at the tail of the list<br></br>
            iv. Else low less than seqno less than high, break [low,high] into [low,seqno-1]
            and [seqno+1,high]
            </p>
            </remarks>
            <summary>
            Remove the given seqno
            </summary>
            <param name="seqno">Sequence number to remove</param>
        </member>
        <member name="M:GCT.Stack.Retransmitter.Entry.run">
            <summary>
            For each interval, call the retransmission callback command
            </summary>
        </member>
        <member name="T:GCT.Stack.Retransmitter.Interval">
            <summary>
            Contains a series of intervals to wait between transmissions
            </summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.Interval.next">
            <summary>Next Interval to use</summary>
        </member>
        <member name="F:GCT.Stack.Retransmitter.Interval.interval">
            <summary>Array of transmission intervals</summary>
        </member>
        <member name="M:GCT.Stack.Retransmitter.Interval.#ctor(System.Int64[])">
            <summary>
            Constructor
            </summary>
            <param name="interval">Array of transmission intervals</param>
        </member>
        <member name="M:GCT.Stack.Retransmitter.Interval.first">
            <summary>
            Returns first interval in the array
            </summary>
            <returns>First interval in the array</returns>
        </member>
        <member name="M:GCT.Stack.Retransmitter.Interval.Next">
            <summary>
            Returns next interval in the array
            </summary>
            <returns>Next interval in the array</returns>
        </member>
        <member name="M:GCT.Stack.Retransmitter.Interval.getInterval">
            <summary>
            Returns all the intervals
            </summary>
            <returns>All the intervals</returns>
        </member>
        <member name="M:GCT.Stack.Retransmitter.Interval.reset">
            <summary>
            Resets the position of the next interval to the first interval
            </summary>
        </member>
        <member name="F:GCT.Stack.AckSenderWindow.retransmit_command">
            <summary>Called to request XMIT of message</summary>
        </member>
        <member name="F:GCT.Stack.AckSenderWindow.msgs">
            <summary>Collection of sent messages.</summary>
        </member>
        <member name="F:GCT.Stack.AckSenderWindow.interval">
            <summary>Intervals to wait between sending</summary>
        </member>
        <member name="F:GCT.Stack.AckSenderWindow.retransmitter">
            <summary>Sends retransmit requests</summary>
        </member>
        <member name="F:GCT.Stack.AckSenderWindow.msg_queue">
            <summary>Stores messages is msgs is 'full'</summary>
        </member>
        <member name="F:GCT.Stack.AckSenderWindow.window_size">
            <summary>The max number of messages in the window, when exceeded messages will be queued</summary>
        </member>
        <member name="F:GCT.Stack.AckSenderWindow.min_threshold">
            <summary>When queueing, after msgs size falls below this value, msgs are added again (queueing stops)</summary>
        </member>
        <member name="F:GCT.Stack.AckSenderWindow.use_sliding_window">
            <summary>Enables use of a sliding window</summary>
        </member>
        <member name="F:GCT.Stack.AckSenderWindow.queueing">
            <summary>If set there are queued messages</summary>
        </member>
        <member name="F:GCT.Stack.AckSenderWindow.transport">
            <summary>Protocol to send messages through</summary>
        </member>
        <member name="M:GCT.Stack.AckSenderWindow.#ctor(GCT.Stack.AckSenderWindow.RetransmitCommand)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="com">
            If not null, its method <code>retransmit()</code> will be called when a message
            needs to be retransmitted (called by the Retransmitter).
            </param>
        </member>
        <member name="M:GCT.Stack.AckSenderWindow.#ctor(GCT.Stack.AckSenderWindow.RetransmitCommand,System.Int64[])">
            <summary>
            Allows the intervals between retransmission to be specified.
            </summary>
            <param name="com">
            If not null, its method <code>retransmit()</code> will be called when a message
            needs to be retransmitted (called by the Retransmitter).
            </param>
            <param name="interval">Array of intervals between retransmissions</param>
        </member>
        <member name="M:GCT.Stack.AckSenderWindow.#ctor(GCT.Stack.AckSenderWindow.RetransmitCommand,System.Int64[],GCT.Stack.Protocol)">
            <summary>
            This constructor whould be used when we want AckSenderWindow to send the message added
            by add(), rather then ourselves
            </summary>
            <param name="com">Method to be called when transmission occurs</param>
            <param name="interval">Array of intervals between retransmissions</param>
            <param name="transport">The Protocol that should be used to <code>passDown</code> the message</param>
        </member>
        <member name="M:GCT.Stack.AckSenderWindow.setWindowSize(System.Int32,System.Int32)">
            <summary>
            Sets the size of the sender window
            </summary>
            <param name="window_size"></param>
            <param name="min_threshold"></param>
        </member>
        <member name="M:GCT.Stack.AckSenderWindow.reset">
            <summary>
            Clears all the messages in the sender window and resets the retransmitter
            </summary>
        </member>
        <member name="M:GCT.Stack.AckSenderWindow.add(System.Int64,GCT.Message)">
            <summary>
            Adds a new message to the retransmission table. If the message won't have received an ack within
            a certain time frame, the retransmission thread will retransmit the message to the receiver. If
            a sliding window protocol is used, we only add up to <code>window_size</code> messages. If the table is
            full, we add all new messages to a queue. Those will only be added once the table drains below a certain
            threshold (<code>min_threshold</code>)
            </summary>
            <param name="seqno">The sequence number of the message</param>
            <param name="msg">The message to be retransmitted</param>
        </member>
        <member name="M:GCT.Stack.AckSenderWindow.ack(System.Int64)">
            <summary>
            Removes the message from <code>msgs</code>, removing them also from retransmission. If
            sliding window protocol is used, and was queueing, check whether we can resume adding elements.
            Add all elements. If this goes above window_size, stop adding and back to queueing. Else
            set queueing to false.
            </summary>
            <param name="seqno"></param>
        </member>
        <member name="M:GCT.Stack.AckSenderWindow.retransmit(System.Int64,System.Int64,GCT.Address)">
            <summary>
            Called by the Retransmitter when a message should be retransmitted.
            </summary>
            <param name="first_seqno">The first sequence number to be retransmitted</param>
            <param name="last_seqno">The last sequence number to be retransmitted. This may be the same as the first if it is only one message.</param>
            <param name="sender">The destination naddress of the message.</param>
        </member>
        <member name="M:GCT.Stack.AckSenderWindow.addMessage(System.Int64,System.Int64,GCT.Message)">
            <summary>
            Used internally to add a message to the retransmitter. The message 
            will be passed down the stack by the Protocol using this Object.
            </summary>
            <param name="seqno">Sequence No of the message.</param>
            <param name="local_seqno">Local Sequence No of the message.</param>
            <param name="msg">Message to be sent and added to the Retransmitter</param>
        </member>
        <member name="M:GCT.Stack.AckSenderWindow.addToQueue(System.Int64,GCT.Message)">
            <summary>
            
            </summary>
            <param name="seqno"></param>
            <param name="msg"></param>
        </member>
        <member name="M:GCT.Stack.AckSenderWindow.removeFromQueue">
            <summary>
            Removes the first <c>Entry</c> in the message collection.
            </summary>
            <returns>If the msg queue contains values the first value is returned</returns>
        </member>
        <member name="T:GCT.Stack.AckSenderWindow.RetransmitCommand">
            <summary>
            Called when the a message should be re-sent. Should be implemented by
            the Protocol using AckSenderWindow.
            </summary>
        </member>
        <member name="M:GCT.Stack.AckSenderWindow.RetransmitCommand.retransmit(System.Int64,GCT.Message)">
            <summary>
            Called when <c>AckSenderWindow.retransmit()</c> is caled from the Retransmitter.
            </summary>
            <param name="seqno">Sequence Number to be resent</param>
            <param name="msg">Message to be resent</param>
        </member>
        <member name="T:GCT.Stack.AckSenderWindow.Entry">
            <summary>
            Class used to store message alongside with its seqno in the message queue
            </summary>
        </member>
        <member name="F:GCT.Stack.AckSenderWindow.Entry.seqno">
            <summary>
            Sequence number of the message.
            </summary>
        </member>
        <member name="F:GCT.Stack.AckSenderWindow.Entry.msg">
            <summary>
            Message associated with the sequence number
            </summary>
        </member>
        <member name="M:GCT.Stack.AckSenderWindow.Entry.#ctor(System.Int64,GCT.Message)">
            <summary>
            Creates a new instance with the specified values.
            </summary>
            <param name="seqno">Sequence number of the message.</param>
            <param name="msg">Message associated with the sequence number</param>
        </member>
        <member name="T:GCT.Address">
            <remarks>
            An <c>Address</c> is also used to uniquely identify a member in a group.
            Each machine can only have 1 locol port open for receiving unicast messages.
            </remarks>
            <summary>
            Identifes an endpoint. Contains an <c>IPAddress</c> and a port.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="M:GCT.Address.#ctor(System.String,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="addr">String representation of the IP Address</param>
            <param name="p">The Port to use</param>
        </member>
        <member name="M:GCT.Address.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="addr"><c>IPAddress</c> object of the Address</param>
            <param name="p">The Port to use</param>
        </member>
        <member name="M:GCT.Address.#ctor(System.Int32)">
            <summary>
            Constructor: will use localhost IP Address
            </summary>
            <param name="port">Local Port</param>
        </member>
        <member name="M:GCT.Address.isMulticastAddress">
            <summary>
            Checks whether the IP Address is a multicast address.
            </summary>
            <returns>True if the Address is a multicast address, otherwise false.</returns>
        </member>
        <member name="M:GCT.Address.Equals(System.Object)">
            <summary>
            Checks for Equality with another object. Overrides base class method.
            </summary>
            <param name="obj">The object to check for equality</param>
            <returns>True is objects are equal, otherwise false</returns>
        </member>
        <member name="M:GCT.Address.GetHashCode">
            <summary>
            Overrides the base class method. Used when the Address used as a key
            in Hashtables.
            </summary>
            <returns>The hashcode of the Address object</returns>
        </member>
        <member name="M:GCT.Address.CompareTo(System.Object)">
            <summary>
            Compares the current object to the specified object. The object must be an Address.
            An Address is said to be larger if it's IP Address is greater, or the IP Address are the same but the port number is greater.
            </summary>
            <param name="obj">Object to Compare the Address with</param>
            <returns>int value representing the comparision.</returns>
        </member>
        <member name="M:GCT.Address.ToString">
            <summary>
            Returns string representation of the object
            </summary>
            <returns>String representation of the object</returns>
        </member>
        <member name="M:GCT.Address.Copy">
            <summary>
            Returns a deep-copy of the Address
            </summary>
            <returns>A deep-copy of the Address</returns>
        </member>
        <member name="P:GCT.Address.IP">
            <summary>
            Get or Set the current IP Address
            </summary>
        </member>
        <member name="P:GCT.Address.Port">
            <summary>
            Get or Set the current IP Port
            </summary>
        </member>
        <member name="T:GCT.Protocols.CAUSAL">
            <remarks>
            
            </remarks>
            <summary>
            Protocol: Causal
            <p><b>Author:</b> Chris Koiak</p>
            <p><b>Date:</b>  16/06/2003</p>
            </summary>
        </member>
        <member name="T:GCT.Stack.Protocol">
            <summary>
            Base class for all Protocol layers.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Stack.Protocol.props">
            <summary>Properties to be set</summary>
        </member>
        <member name="F:GCT.Stack.Protocol.up_protocol">
            <summary>Protocol 'above' this Protocol</summary>
        </member>
        <member name="F:GCT.Stack.Protocol.down_protocol">
            <summary>Protocol 'below' this Protocol</summary>
        </member>
        <member name="F:GCT.Stack.Protocol.stack">
            <summary>ProtocolSinkStack this Protocol belongs to</summary>
        </member>
        <member name="F:GCT.Stack.Protocol.up_queue">
            <summary>Queue of messages that have been passed up</summary>
        </member>
        <member name="F:GCT.Stack.Protocol.down_queue">
            <summary>Queue of messages that have been passed down</summary>
        </member>
        <member name="F:GCT.Stack.Protocol.up_handler">
            <summary>Thread for passing messages up in to the Protocol</summary>
        </member>
        <member name="F:GCT.Stack.Protocol.down_handler">
            <summary>Thread for passing messages down in to the Protocol</summary>
        </member>
        <member name="F:GCT.Stack.Protocol.down_thread">
            <summary>Determines whether the down_handler thread should be started</summary>
        </member>
        <member name="F:GCT.Stack.Protocol.up_thread">
            <summary>Determines whether the up_handler thread should be started</summary>
        </member>
        <member name="F:GCT.Stack.Protocol.name">
            <summary>Each Protocol must have a unique name</summary>
        </member>
        <member name="M:GCT.Stack.Protocol.init">
            <remarks>Called after instance has been created (null constructor) and before protocol is started</remarks>
            <summary>Initilises the Protocol</summary>
        </member>
        <member name="M:GCT.Stack.Protocol.start">
            <summary>Starts the Protocol</summary>
        </member>
        <member name="M:GCT.Stack.Protocol.stop">
            <summary>Stops the Protocol</summary>
        </member>
        <member name="M:GCT.Stack.Protocol.getUpQueue">
            <summary>
            Returns the Up Queue
            </summary>
            <returns>The Up Queue</returns>
        </member>
        <member name="M:GCT.Stack.Protocol.getDownQueue">
            <summary>
            Returns the Down Queue
            </summary>
            <returns>The Down Queue</returns>
        </member>
        <member name="M:GCT.Stack.Protocol.requiredUpServices">
            <summary>
            List of events that are required to be answered by some layer above.
            </summary>
            <returns>An array of ints</returns>
        </member>
        <member name="M:GCT.Stack.Protocol.requiredDownServices">
            <summary>
            List of events that are required to be answered by some layer below.
            </summary>
            <returns>An array of ints</returns>
        </member>
        <member name="M:GCT.Stack.Protocol.providedUpServices">
            <summary>
            List of events that are provided to layers above (they will be handled when sent down from above).
            </summary>
            <returns>An array of ints</returns>
        </member>
        <member name="M:GCT.Stack.Protocol.providedDownServices">
            <summary>
            List of events that are provided to layers below (they will be handled when sent down from below).
            </summary>
            <returns>An array of ints</returns>
        </member>
        <member name="M:GCT.Stack.Protocol.startUpHandler">
            <summary>
            Starts the Up Handler thread if up_thread is true
            </summary>
        </member>
        <member name="M:GCT.Stack.Protocol.startDownHandler">
            <summary>
            Starts the Down Handler thread if down_thread is true
            </summary>
        </member>
        <member name="M:GCT.Stack.Protocol.stopInternal">
            <summary>
            Stops the Up and Down Handler threads
            </summary>
        </member>
        <member name="M:GCT.Stack.Protocol.receiveUpEvent(GCT.Event)">
            <remarks>If the up_handler thread
            is not available (up_thread == false), then directly call the up() methodelse add the
            event to the up queue.
            </remarks>
            <summary>
            Receive an event from the layer below
            </summary>
            <param name="evt">Event passed up</param>
        </member>
        <member name="M:GCT.Stack.Protocol.receiveDownEvent(GCT.Event)">
            <remarks>
            If the down_handler thread
            is not available (down_thread == false), then directly call the down() method, else add the
            event to the down queue.
            </remarks>
            <summary>
            Receive an event from the layer above
            </summary>
            <param name="evt">Event passed down</param>
        </member>
        <member name="M:GCT.Stack.Protocol.passUp(GCT.Event)">
            <remarks>
            Typically called
            by the implementation of <code>Up</code> (when done).
            </remarks>
            <summary>
            Causes the event to be forwarded to the next layer up in the hierarchy.
            </summary>
            <param name="evt">Event to passed up</param>
        </member>
        <member name="M:GCT.Stack.Protocol.passDown(GCT.Event)">
            <remarks>
            Typically called
            by the implementation of <code>Down</code> (when done).
            </remarks>
            <summary>
            Causes the event to be forwarded to the next layer down in the hierarchy.
            </summary>
            <param name="evt">Event to passed down</param>
        </member>
        <member name="M:GCT.Stack.Protocol.up(GCT.Event)">
            <remarks>
            Usually the current layer will want to examine
            the event type and - depending on its type - perform some computation
            (e.g. removing headers from a MSG event type, or updating the internal membership list
            when receiving a VIEW_CHANGE event).
            Finally the event is either a) discarded, or b) an event is sent down
            the stack using <code>passDown()</code> or c) the event (or another event) is sent up
            the stack using <code>passUp()</code>.
            </remarks>
            <summary>
            An event was received from the layer below.
            </summary>
            <param name="evt"></param>
        </member>
        <member name="M:GCT.Stack.Protocol.down(GCT.Event)">
            <remarks>
            The layer may want to examine its type and perform
            some action on it, depending on the event's type. If the event is a message MSG, then
            the layer may need to add a header to it (or do nothing at all) before sending it down
            the stack using <code>passDown()</code>. In case of a GET_ADDRESS event (which tries to
            retrieve the stack's address from one of the bottom layers), the layer may need to send
            a new response event back up the stack using <code>passUp()</code>.
            </remarks>
            <summary>
            An event is to be sent down the stack.
            </summary>
            <param name="evt"></param>
        </member>
        <member name="M:GCT.Stack.Protocol.setPropertiesInternal(System.Data.PropertyCollection)">
            <summary>
            Removes and sets all generic properties of a Protocol, then passes remainder of properties on to implementation
            </summary>
            <param name="properties">Collection of properties</param>
            <returns>False if properties were specified that are not know, otherwise true</returns>
        </member>
        <member name="M:GCT.Stack.Protocol.setProperties(System.Data.PropertyCollection)">
            <summary>
            Sets the properties specified in the configuration string
            </summary>
            <param name="props">Properties to set</param>
            <returns>False if properties were specified that are not know, otherwise true</returns>
        </member>
        <member name="M:GCT.Stack.Protocol.downHandler">
            <summary>
            Thread to allow messages to be passed down asynchronously 
            </summary>
        </member>
        <member name="M:GCT.Stack.Protocol.upHandler">
            <summary>
            Thread to allow messages to be passed up asynchronously 
            </summary>
        </member>
        <member name="P:GCT.Stack.Protocol.Name">
            <summary>
            Gets and sets the unique Protocol name
            </summary>
        </member>
        <member name="P:GCT.Stack.Protocol.UpProtocol">
            <summary>
            Gets and sets the Protocol above this Protocol
            </summary>
        </member>
        <member name="P:GCT.Stack.Protocol.DownProtocol">
            <summary>
            Gets and sets the Protocol below this Protocol
            </summary>
        </member>
        <member name="P:GCT.Stack.Protocol.ProtocolSinkStack">
            <summary>
            Sets the ProtocolSinkStack associated with this Protocol
            </summary>
        </member>
        <member name="M:GCT.Protocols.CAUSAL.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GCT.Protocols.CAUSAL.getName">
            <summary>
            Returns unique <c>Protocol</c> name
            </summary>
            <returns>Unique <c>Protocol</c> name</returns>
        </member>
        <member name="M:GCT.Protocols.CAUSAL.up(GCT.Event)">
            <summary>
            Processes <c>Events</c> traveling up the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.CAUSAL.down(GCT.Event)">
            <summary>
            Processes <c>Events</c> traveling down the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="T:GCT.Protocols.CausalHeader">
            <summary>
            Causal Ordering Header.
            <p><b>Author:</b> Chris Koiak</p>
            <p><b>Date:</b>  17/06/2003</p>
            </summary>
        </member>
        <member name="T:GCT.Header">
            <summary>
            Used to append messages with stack information
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Header.className">
            <summary>
            Name of associated clss
            </summary>
        </member>
        <member name="M:GCT.Header.ToString">
            <summary>
            Default String representation of the Header
            </summary>
            <returns>String representation of the Header</returns>
        </member>
        <member name="M:GCT.Header.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <remarks>
            An abstract class cannot be marked as [Serializable] therefore this
            method is needed to tell sub-classes to be serializable
            </remarks>
            <summary>
            Used to enforce serialization property of sub-class.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="F:GCT.Protocols.CausalHeader.vStamp">
            <summary>Representation of current Vector Time Stamp</summary>
        </member>
        <member name="M:GCT.Protocols.CausalHeader.#ctor(GCT.Protocols.TransportableVectorTimeStamp)">
            <summary>Constructor</summary>
            <param name="vStamp">Vector time stamp</param>
        </member>
        <member name="M:GCT.Protocols.CausalHeader.ToString">
            <summary>
            Returns a string representation of the Header object
            </summary>
            <returns>A string representation of the Header object</returns>
        </member>
        <member name="M:GCT.Protocols.CausalHeader.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialises the information
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="context">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="M:GCT.Protocols.CausalHeader.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor: Deserialises the information and recreates the instance.
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="ctxt">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="P:GCT.Protocols.CausalHeader.VectorTime">
            <summary>
            Gets the vector time stamp
            </summary>
        </member>
        <member name="T:GCT.Channel">
            <summary>
            Abstract class for any implementation of a channel
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="T:GCT.Transport">
            <summary>
            Simply Transport interface
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="M:GCT.Transport.send(GCT.Message)">
            <summary>Sends a message on the transport</summary>
            <param name="msg">Message to send</param>
        </member>
        <member name="M:GCT.Transport.receive(System.Int32)">
            <summary>Receives a message from the transport</summary>
        </member>
        <member name="F:GCT.Channel.up_handler">
            <summary>
            All events will be sent to this class once received.
            </summary>
        </member>
        <member name="F:GCT.Channel.channel_listener">
            <summary>
            Allows listening on the channel. The listener will be notified of channel closing, etc.
            </summary>
        </member>
        <member name="M:GCT.Channel.#ctor">
            <summary>
            Constructor: Uses predefined stack.
            </summary>
        </member>
        <member name="M:GCT.Channel.#ctor(System.Object)">
            <summary>
            Constructor: Stack and properties are specified
            </summary>
            <param name="properties">Properties of Channel stack</param>
        </member>
        <member name="M:GCT.Channel.connect(System.String)">
            <summary>
            Connects the Channel to a group.
            </summary>
            <param name="channel_name">Group to connect to (or create).</param>
        </member>
        <member name="M:GCT.Channel.disconnect">
            <summary>
            Disconnects the Channel from the group
            </summary>
        </member>
        <member name="M:GCT.Channel.close">
            <summary>
            Disconnects and closes the Channel.
            </summary>
        </member>
        <member name="M:GCT.Channel.open">
            <summary>
            Re-opens a closed channel.
            </summary>
        </member>
        <member name="M:GCT.Channel.isOpen">
            <summary>
            Checks if the Channel is Open.
            </summary>
            <returns>True if the Channel is open</returns>
        </member>
        <member name="M:GCT.Channel.isConnected">
            <summary>
            Checks if the Channel is Connected.
            </summary>
            <returns>True if the Channel is Connected</returns>
        </member>
        <member name="M:GCT.Channel.send(GCT.Message)">
            <summary>
            Sends a message through the Channel
            </summary>
            <param name="msg">Message to be sent</param>
        </member>
        <member name="M:GCT.Channel.down(GCT.Event)">
            <summary>
            Passes an event down the protocol stack
            </summary>
            <param name="evt">Event to be passed down the stack</param>
        </member>
        <member name="M:GCT.Channel.receive(System.Int32)">
            <summary>
            Receives an event from the channel
            </summary>
            <param name="timeout">Time (ms) to wait for a message</param>
            <returns>The next Event received by the channel</returns>
        </member>
        <member name="M:GCT.Channel.peek(System.Int32)">
            <summary>
            Performs the same as <c>receive()</c> but does not remove the Event
            </summary>
            <param name="timeout">Time (ms) to wait for a message</param>
            <returns>The next Event received by the channel</returns>
        </member>
        <member name="M:GCT.Channel.getView">
            <summary>
            Returns the current view of the Channel.
            </summary>
            <returns>The current view of the Channel</returns>
        </member>
        <member name="M:GCT.Channel.getLocalAddress">
            <summary>
            Returns the current Address (IP + Port) the Channel is using
            </summary>
            <returns>The local Address of the Channel</returns>
        </member>
        <member name="M:GCT.Channel.getChannelName">
            <summary>
            Returns the name of the group the Channel is connected to.
            </summary>
            <returns>The name of the group the Channel is connected to</returns>
        </member>
        <member name="M:GCT.Channel.setUpHandler(GCT.UpHandler)">
            <summary>
            Sets the UpHandler that will receive all Events from the Channel
            </summary>
            <param name="up_handler">The Uphandler object to receive the events</param>
        </member>
        <member name="M:GCT.Channel.setChannelListener(GCT.ChannelListener)">
            <summary>
            Sets the ChannelListener that will be notified of changes to the channel
            </summary>
            <param name="channel_listener">The ChannelListener object to receive changes</param>
        </member>
        <member name="M:GCT.Channel.setOpt(System.String,System.Object)">
            <summary>
            Sets a variety of options within the channel
            </summary>
            <param name="option">The string representation of the option</param>
            <param name="value">The value that the option should be set to</param>
        </member>
        <member name="T:GCT.ChannelListener">
            <summary>
            Used to listen for connection changes in the Channel
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="M:GCT.ChannelListener.channelConnected(GCT.Channel)">
            <summary>
            Channel Connected Event
            </summary>
            <param name="channel">Channel that was connected</param>
        </member>
        <member name="M:GCT.ChannelListener.channelDisconnected(GCT.Channel)">
            <summary>
            Channel Disconnected Event
            </summary>
            <param name="channel">Channel that was disconnected</param>
        </member>
        <member name="M:GCT.ChannelListener.channelClosed(GCT.Channel)">
            <summary>
            Channel Closed Event
            </summary>
            <param name="channel">Channel that was closed</param>
        </member>
        <member name="M:GCT.ChannelListener.channelShunned">
            <summary>
            Channel Shunned Event
            </summary>
        </member>
        <member name="M:GCT.ChannelListener.channelReconnected(GCT.Address)">
            <summary>
            Channel Reconnected Event 
            </summary>
            <param name="addr">Channel that was reconnected</param>
        </member>
        <member name="T:GCT.Protocols.ClientGmsImpl">
            <remarks>
            Whenever a new member wants to join a group, it starts in the CLIENT role.
            No multicasts to the group will be received and processed until the member has been joined and
            turned into a SERVER (either coordinator or participant, mostly just participant). This class
            only implements <code>Join</code> (called by clients who want to join a certain group, and
            <code>ViewChange</code> which is called by the coordinator that was contacted by this client, to
            tell the client what its initial membership is.</remarks>
            <summary>
            Client role of the GMS protocol.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="T:GCT.Protocols.GmsImpl">
            <summary>
            GMS implementation.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.GmsImpl.gms">
            <summary>
            GMS Protocol, used to call non-implementation specific methods.
            </summary>
        </member>
        <member name="F:GCT.Protocols.GmsImpl.name">
            <summary>
            Name of GMS implementation
            </summary>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.join(GCT.Address)">
            <summary>
            Join a group.
            </summary>
            <param name="mbr">Local Address</param>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.leave(GCT.Address)">
            <summary>
            Leave current group.
            </summary>
            <param name="mbr">Local Address</param>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.handleJoinResponse(GCT.Protocols.JoinRsp)">
            <summary>
            Process response to join request
            </summary>
            <param name="join_rsp">Response to Join request</param>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.handleLeaveResponse">
            <summary>
            Process leave request
            </summary>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.suspect(GCT.Address)">
            <summary>
            Supected member.
            </summary>
            <param name="mbr">Suspected member</param>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.unsuspect(GCT.Address)">
            <summary>
            Unsuspect member 
            </summary>
            <param name="mbr">Previously suspected member</param>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.handleJoin(GCT.Address)">
            <summary>
            Process join request
            </summary>
            <param name="mbr">Joining member</param>
            <returns>Response to join request</returns>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.handleLeave(GCT.Address,System.Boolean)">
            <summary>
            Process leave request
            </summary>
            <param name="mbr">Leaving Member</param>
            <param name="suspected">True if member has been forced to leave</param>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.handleViewChange(GCT.View,GCT.Digest)">
            <summary>
            Process change to current view
            </summary>
            <param name="new_view">New View</param>
            <param name="digest">Digest associated with the view</param>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.handleSuspect(GCT.Address)">
            <summary>
            Process suspected member.
            </summary>
            <param name="mbr"></param>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.handleUpEvent(GCT.Event)">
            <summary>
            Allows <c>up()</c> <c>Events</c> to be captured by the GMS implementation
            </summary>
            <param name="evt">Up Event</param>
            <returns>True is processing completed correctly</returns>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.handleDownEvent(GCT.Event)">
            <summary>
            Allows <c>down()</c> <c>Events</c> to be captured by the GMS implementation
            </summary>
            <param name="evt">Down Event</param>
            <returns>True is processing completed correctly</returns>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.init">
            <summary>
            Initilisation for GMS implementation
            </summary>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.start">
            <summary>
            Start for GMS implementation
            </summary>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.stop">
            <summary>
            Stop for GMS implementation
            </summary>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.getName">
            <summary>
            Returns GMS implementation name
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.Protocols.GmsImpl.wrongMethod(System.String)">
            <summary>
            Used by implementation to signify a method has been called on an incorrect implementation
            </summary>
            <param name="method_name"></param>
        </member>
        <member name="F:GCT.Protocols.ClientGmsImpl.initial_mbrs">
            <summary>Holds the initial members responses</summary>
        </member>
        <member name="F:GCT.Protocols.ClientGmsImpl.join_promise">
            <summary>Synchronises leave requests and resposnes</summary>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.#ctor(GCT.Protocols.GMS)">
            <summary>
            Constructor
            </summary>
            <param name="g">GMS Protocol using this implementation</param>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.join(GCT.Address)">
            <remarks>
            Determines the coordinator and sends a unicast 
            handleJoin() message to it. The coordinator returns a JoinRsp and then broadcasts the new view, which
            contains a message digest and the current membership (including the joiner). The joiner is then
            supposed to install the new view and the digest and starts accepting mcast messages. Previous
            mcast messages were discarded as we were not a member.<p>
            If successful, impl is changed to an instance of ParticipantGmsImpl. 
            Otherwise, we continue trying to send join() messages to the coordinator, 
            until we succeed (or there is no member in the group. In this case, we create our own singleton group).
            <p>When GMS.disable_initial_coord is set to true, then we won't become coordinator on receiving an initial
            membership of 0, but instead will retry (forever) until we get an initial membership of > 0.</p>
            </p>
            </remarks>
            <summary>
            Joins this process to a group.
            </summary>
            <param name="mbr">The local Address of the process</param>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.leave(GCT.Address)">
            <summary>
            Not implemented by Client GMS
            </summary>
            <param name="mbr"></param>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.handleJoinResponse(GCT.Protocols.JoinRsp)">
            <summary>
            Not implemented by Client GMS
            </summary>
            <param name="join_rsp"></param>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.handleLeaveResponse">
            <summary>
            Not implemented by Client GMS
            </summary>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.suspect(GCT.Address)">
            <summary>
            Not implemented by Client GMS
            </summary>
            <param name="mbr"></param>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.unsuspect(GCT.Address)">
            <summary>
            Not implemented by Client GMS
            </summary>
            <param name="mbr"></param>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.handleJoin(GCT.Address)">
            <summary>
            Not implemented by Client GMS
            </summary>
            <param name="mbr"></param>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.handleLeave(GCT.Address,System.Boolean)">
            <summary>
            Not implemented by Client GMS
            </summary>
            <param name="mbr"></param>
            <param name="suspected"></param>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.handleViewChange(GCT.View,GCT.Digest)">
            <summary>
            All views are ignored while GMS is a client
            </summary>
            <param name="new_view">Ignored</param>
            <param name="digest">Ignored</param>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.handleSuspect(GCT.Address)">
            <summary>
            All views are ignored while GMS is a client
            </summary>
            <param name="mbr"></param>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.handleUpEvent(GCT.Event)">
            <summary>
            Called by the GMS if it can't process the Event.
            </summary>
            <param name="evt">The Event passed up to the GMS</param>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.installView(GCT.View)">
            <remarks>
            A value of false will be returned if the new view doesn't contain the 
            this member.
            </remarks>
            <summary>
            Installs the new view returned from GMS Coord.
            </summary>
            <param name="new_view">The new <code>View</code> to install</param>
            <returns>True if successful, otherwise false.</returns>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.sendJoinMessage(GCT.Address,GCT.Address)">
            <summary>
            Sends a join message to the coordinator of the group.
            </summary>
            <param name="coord">The Address of the Coordinator</param>
            <param name="mbr">The local Address (i.e. this member)</param>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.findInitialMembers">
            <remarks>
            The PING layer will intercept this Event and return the initial members of the group.
            </remarks>
            <summary>
            Sends Event down stack requesting initial members. Causes private list <c>initial_mbrs</c> to be populated.
            </summary>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.determineCoord(System.Collections.ArrayList)">
            <summary>
            Determines the most likely coordinator from the responses
            </summary>
            <param name="mbrs">The list of suggested coordinators</param>
            <returns>The coordinator with the most votes</returns>
        </member>
        <member name="M:GCT.Protocols.ClientGmsImpl.becomeSingletonMember(GCT.Address)">
            <remarks>
            Called by <c>Join()</c> when no initial members can be detected
            </remarks>
            <summary>
            Changes the GMS to a Coord implementation
            </summary>
            <param name="mbr">Local Address representing this Channel</param>
        </member>
        <member name="T:GCT.Stack.Configurator">
            <remarks>
            This class is responsible for creating instances of the protocol layers
            from the textual configuration string. 
            Once the layers are created, they will be configured.
            </remarks>
            <summary>
            Sets up ProtocolSinkStack based on configuration string.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="M:GCT.Stack.Configurator.setupStack(System.String,GCT.Stack.ProtocolSinkStack)">
            <remarks>
            The following steps are followed:
            <list type="">
            <item>A <c>ProtocolConfiguration</c> object is created for each protocol</item>
            <item>The <c>Protocol</c>s are created from the <c>ProtocolConfiguration</c> objects</item>
            <item>The Protocols are all connected together</item>
            </list>
            </remarks>
            <summary>
            Sets up the <c>ProtocolSinkStack</c> with the specified configuration string.
            </summary>
            <param name="configuration">The String configuration of the stack</param>
            <param name="st">Reference to the <c>ProtocolSinkStack</c> which each <c>Protocol</c> should reference</param>
            <returns>The top-most <c>Protocol</c> in the stack</returns>
        </member>
        <member name="M:GCT.Stack.Configurator.parseConfigurations(System.String)">
            <summary>
            Creates a <c>ProtocolConfiguration</c> instance for each protocol in the configuration string
            </summary>
            <param name="config">The configuration string</param>
            <returns>The array of configuration objects</returns>
        </member>
        <member name="M:GCT.Stack.Configurator.createProtocols(GCT.Stack.Configurator.ProtocolConfiguration[],GCT.Stack.ProtocolSinkStack)">
            <summary>
            Creates an array of <c>Protocols</c> from the configurations
            </summary>
            <param name="protocol_configs">Array of <c>ProtocolConfiguration</c> objects</param>
            <param name="stack">Instance <c>ProtocolSinkStack</c> which the Protocol layers should reference</param>
            <returns>Array of <c>Protocol</c> objects</returns>
        </member>
        <member name="M:GCT.Stack.Configurator.sanityCheck(GCT.Stack.Protocol[])">
            <summary>
            Checks all <c>Protocol</c>s are unique and that 
            each required up/down service is provided
            </summary>
            <param name="protocols">Protocols that will be used for the stack</param>
        </member>
        <member name="M:GCT.Stack.Configurator.providesUpServices(System.Int32,System.Collections.ArrayList,System.Int32)">
            <summary>
            Check whether any of the protocols 'below' end_index provide <c>Event</c> (evt_type)
            </summary>
            <param name="end_index">Position in the stack which Protocol must be below</param>
            <param name="req_list">List of services/events provided by the Procotols</param>
            <param name="evt_type">Service that is required</param>
            <returns>True if service is provided by a 'lower' protocol, otherwise false</returns>
        </member>
        <member name="M:GCT.Stack.Configurator.providesDownServices(System.Int32,System.Collections.ArrayList,System.Int32)">
            <summary>
            Check whether any of the protocols 'above' end_index provide <c>Event</c> (evt_type)
            </summary>
            <param name="start_index">Position in the stack which Protocol must be above</param>
            <param name="req_list">List of services/events provided by the Procotols</param>
            <param name="evt_type">Service that is required</param>
            <returns>True if service is provided by a 'higher' protocol, otherwise false</returns>
        </member>
        <member name="M:GCT.Stack.Configurator.connectProtocols(GCT.Stack.Protocol[])">
            <remarks>
            Prootocols will be linked according to their position in the list.
            </remarks>
            <summary>
            Connects all the <c>Protocols</c> together.
            </summary>
            <param name="layer_list">List of <c>Protocol</c>s to be connected</param>
            <returns>The top-most <c>Protocol</c> in the connected stack</returns>
        </member>
        <member name="M:GCT.Stack.Configurator.getBottommostProtocol(GCT.Stack.Protocol)">
            <summary>
            Moves down the stack until the last <c>Protocol</c> is discovered
            </summary>
            <param name="prot_stack">Top protocol in the stack</param>
            <returns>The Bottom-most <c>Protocol</c> found</returns>
        </member>
        <member name="M:GCT.Stack.Configurator.startProtocolStack(GCT.Stack.Protocol)">
            <summary>
            Starts the Up and Down Handler threads in every Protocol.
            </summary>
            <param name="bottom_prot">Start every Protocol from this one and above</param>
        </member>
        <member name="M:GCT.Stack.Configurator.stopProtocolStack(GCT.Stack.Protocol)">
            <summary>
            Stops all <c>Protocol</c> Up and Down Handler threads.
            </summary>
            <param name="start_prot">Stop every Protocol from this one down</param>
        </member>
        <member name="T:GCT.Stack.Configurator.ProtocolReq">
            <summary>
            Internal Class for holding a Protocols required and provided services
            </summary>
        </member>
        <member name="M:GCT.Stack.Configurator.ProtocolReq.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Protocol Name</param>
        </member>
        <member name="M:GCT.Stack.Configurator.ProtocolReq.providesUpService(System.Int32)">
            <summary>
            Checks if <c>Protocol</c> provides the up service
            </summary>
            <param name="evt_type">Service required</param>
            <returns>True if service is provided, otherwise false</returns>
        </member>
        <member name="M:GCT.Stack.Configurator.ProtocolReq.providesDownService(System.Int32)">
            <summary>
            Checks if <c>Protocol</c> provides the down service
            </summary>
            <param name="evt_type">Service required</param>
            <returns>True if service is provided, otherwise false</returns>
        </member>
        <member name="T:GCT.Stack.Configurator.ProtocolConfiguration">
            <summary>
            Internal Class that holds the Configuration for a Protocol
            </summary>
        </member>
        <member name="M:GCT.Stack.Configurator.ProtocolConfiguration.#ctor(System.String)">
            <remarks>
            Calls <c>setContents()</c> on initialisation
            </remarks>
            <summary>
            Constructor.
            </summary>
            <param name="config_str">The configuration string for a single Protocol</param>
        </member>
        <member name="M:GCT.Stack.Configurator.ProtocolConfiguration.setContents(System.String)">
            <summary>
            Populates a collection with the properties specified in the config string
            </summary>
            <param name="config_str">Configuration string</param>
        </member>
        <member name="M:GCT.Stack.Configurator.ProtocolConfiguration.createLayer(GCT.Stack.ProtocolSinkStack)">
            <remarks>
            Uses <c>Activator.CreateInstance()</c> initialise each <c>Protocol</c>
            </remarks>
            <summary>
            Creates the Protocol, sets the properties and calls <c>init()</c> 
            </summary>
            <param name="st">The <c>ProtocolSinkStack</c> the <c>Protocol</c>
            should be linked to
            </param>
            <returns></returns>
        </member>
        <member name="T:GCT.Protocols.CoordGmsImpl">
            <remarks>
            Accepts JOIN and LEAVE requests and emits view changes accordingly.
            </remarks>
            <summary>
            Coordinator role of the GMS protocol.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.CoordGmsImpl.leaving">
            <summary>
            Indicates if the member is currently leaving
            </summary>
        </member>
        <member name="M:GCT.Protocols.CoordGmsImpl.#ctor(GCT.Protocols.GMS)">
            <summary>
            Constructor
            </summary>
            <param name="g">GMS Protocol using this implementation</param>
        </member>
        <member name="M:GCT.Protocols.CoordGmsImpl.join(GCT.Address)">
            <summary>
            Not implemented by Coord GMS
            </summary>
            <param name="mbr"></param>
        </member>
        <member name="M:GCT.Protocols.CoordGmsImpl.leave(GCT.Address)">
            <remarks>
            This method will can <c>handleLeave()</c> as if it was received by participant member.
            </remarks>
            <summary>
            Leave current group. Another member will assume the coordinator role
            </summary>
            <param name="mbr">Local Address</param>
        </member>
        <member name="M:GCT.Protocols.CoordGmsImpl.handleJoinResponse(GCT.Protocols.JoinRsp)">
            <summary>
            Not implemented by Coord GMS
            </summary>
            <param name="join_rsp"></param>
        </member>
        <member name="M:GCT.Protocols.CoordGmsImpl.handleLeaveResponse">
            <summary>
            Not implemented by Coord GMS
            </summary>
        </member>
        <member name="M:GCT.Protocols.CoordGmsImpl.suspect(GCT.Address)">
            <summary>
            Forces the suspected member to leave the group.
            </summary>
            <param name="mbr">Member to suspect</param>
        </member>
        <member name="M:GCT.Protocols.CoordGmsImpl.unsuspect(GCT.Address)">
            <summary>
            No action is taken to unsuspect a member
            </summary>
            <param name="mbr">Member to unsuspect</param>
        </member>
        <member name="M:GCT.Protocols.CoordGmsImpl.handleJoin(GCT.Address)">
            <summary>
            Adds members to the Membership and multicast the new view.
            </summary>
            <param name="mbr">New Member requesting join</param>
            <returns><c>JoinRsp</c> containing new view and digest</returns>
        </member>
        <member name="M:GCT.Protocols.CoordGmsImpl.handleLeave(GCT.Address,System.Boolean)">
            <remarks>
              Exclude <code>mbr</code> from the membership. If <code>suspected</code> is true, then
              this member crashed and therefore is forced to leave, otherwise it is leaving voluntarily.
            </remarks>
            <summary>
            Excludes the member from the group
            </summary>
            <param name="mbr">The member that will be removed.</param>
            <param name="suspected">If true the member is being forced to leave</param>
        </member>
        <member name="M:GCT.Protocols.CoordGmsImpl.handleViewChange(GCT.View,GCT.Digest)">
            <summary>
            Installs a new view within the process
            </summary>
            <param name="new_view">The new view to be installed</param>
            <param name="digest">The digest associated with the new view</param>
        </member>
        <member name="M:GCT.Protocols.CoordGmsImpl.handleSuspect(GCT.Address)">
            <summary>
            Forces the suspected member to leave the group.
            </summary>
            <param name="mbr">Suspected member</param>
        </member>
        <member name="T:GCT.Digest">
            <remarks>
            A message digest, which is used by NAKACK for keeping track of current 
            seqnos for all members. It contains pairs of senders and a range of seqnos 
            (low and high), where each sender is associated with its highest and 
            lowest seqnos seen so far. That is, the lowest seqno which was not yet garbage-collected and the highest that was seen so far and is deliverable (or was already delivered) to the application. A range of [0 - 0] means no messages have been received yet. 
            <p>
            The highest <i>seen</i> sequence number is used to disseminate information about the last (highest) message M 
            received from a sender P. Since we might be using a negative acknowledgment 
            message numbering scheme, we would never know if the last message was lost. 
            Therefore we periodically gossip and include the last message seqno. Members 
            who haven't seen it (e.g. because msg was dropped) will request a 
            retransmission.
            </p>
            </remarks>
            <author>Chris Koiak</author>
            <author>Bela Ban</author>
            <summary>
            Message Digest for every member in the current group.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Digest.senders">
            <summary>
            All members in the group
            </summary>
        </member>
        <member name="M:GCT.Digest.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="size">Size of the Digest (i.e. number of members</param>
        </member>
        <member name="M:GCT.Digest.add(GCT.Address,System.Int64,System.Int64)">
            <summary>
            Adds a member into the Digest.
            </summary>
            <param name="sender">Address of new member to add</param>
            <param name="low_seqno">Lowest Sequence num received from this member</param>
            <param name="high_seqno">Highest Sequence num received from this member</param>
        </member>
        <member name="M:GCT.Digest.add(GCT.Address,System.Int64,System.Int64,System.Int64)">
            <summary>
            Adds a member into the Digest.
            </summary>
            <param name="sender">Address of new member to add</param>
            <param name="low_seqno">Lowest Sequence num received from this member</param>
            <param name="high_seqno">Highest Sequence num received from this member</param>
            <param name="high_seqno_seen">Highest Sequence num seen from this member</param>
        </member>
        <member name="M:GCT.Digest.add(GCT.Digest)">
            <summary>
            Adds a number of members into the Digest.
            </summary>
            <param name="d">Digest to add into this Digest</param>
        </member>
        <member name="M:GCT.Digest.merge(GCT.Digest)">
            <remarks>
            For each member in the new digest the <c>merge()</c> method will be called. The digest must
            have enough space to merge the new digest.
            </remarks>
            <summary>
            Merge two digest together.
            </summary>
            <param name="d">Digest to merge into this Digest</param>
        </member>
        <member name="M:GCT.Digest.merge(GCT.Address,System.Int64,System.Int64,System.Int64)">
            <remarks>
            Similar to add(), but if the sender already exists, its seqnos will be modified (no new entry) as follows:
            <list>
            <item>this.low_seqno=min(this.low_seqno, low_seqno)</item>
            <item>this.high_seqno=max(this.high_seqno, high_seqno)</item>
            <item>this.high_seqno_seen=max(this.high_seqno_seen, high_seqno_seen)</item>
            </list>
            If the sender doesn not exist, a new entry will be added (provided there is enough space)
            </remarks>
            <summary>
            Merge member into Digest. Also called from <c>merge(Digest)</c>.
            </summary>
            <param name="sender">Member to merge into Digest</param>
            <param name="low_seqno">Lowest sequence number associated with this member</param>
            <param name="high_seqno">Highest sequence number associated with this member</param>
            <param name="high_seqno_seen">Highest sequence number seen associated with this member</param>
        </member>
        <member name="M:GCT.Digest.getIndex(GCT.Address)">
            <summary>
            Gets the position of the member in the Digest
            </summary>
            <param name="sender">Member to check</param>
            <returns>Position of member</returns>
        </member>
        <member name="M:GCT.Digest.contains(GCT.Address)">
            <summary>
            Checks if a member is in the Digest
            </summary>
            <param name="sender">Member to check</param>
            <returns>True if the message is in the Digest</returns>
        </member>
        <member name="M:GCT.Digest.incrementHighSeqno(GCT.Address)">
            <summary>
            Increment the sender's high_seqno by 1
            </summary>
            <param name="sender">Member to increment</param>
        </member>
        <member name="M:GCT.Digest.size">
            <summary>
            Number of members in the Digest
            </summary>
            <returns>Number of members in the Digest</returns>
        </member>
        <member name="M:GCT.Digest.senderAt(System.Int32)">
            <summary>
            Gets the member at the specified position
            </summary>
            <param name="index">Position to get member from</param>
            <returns>Address of member</returns>
        </member>
        <member name="M:GCT.Digest.resetAt(System.Int32)">
            <remarks>
            This happens when a member has left the group,
            but it is still in the digest. Resetting its seqnos ensures that no-one will request a message
            retransmission from the dead member.
            </remarks>
            <summary>
            Resets the seqnos for the sender at 'index' to 0.
            </summary>
            <param name="index">Index to reset</param>
        </member>
        <member name="M:GCT.Digest.reset(System.Int32)">
            <summary>
            Resets the digest.
            </summary>
            <param name="size">New Size of the Digest</param>
        </member>
        <member name="M:GCT.Digest.lowSeqnoAt(System.Int32)">
            <summary>
            Gets the lowest sequence number
            </summary>
            <param name="index">Index to get the lowest seq numbr from</param>
            <returns>Lowest sequence number</returns>
        </member>
        <member name="M:GCT.Digest.highSeqnoAt(System.Int32)">
            <summary>
            Gets the highest sequence number
            </summary>
            <param name="index">Index to get the highest seq numbr from</param>
            <returns>Highest sequence number</returns>
        </member>
        <member name="M:GCT.Digest.highSeqnoSeenAt(System.Int32)">
            <summary>
            Gets the highest seen sequence number
            </summary>
            <param name="index">Index to get the highest seen seq numbr from</param>
            <returns>Highest seen sequence number</returns>
        </member>
        <member name="M:GCT.Digest.highSeqnoAt(GCT.Address)">
            <summary>
            Gets the highest sequence number
            </summary>
            <param name="sender">Member that the highest sequence number is required for</param>
            <returns>Highest sequence number</returns>
        </member>
        <member name="M:GCT.Digest.highSeqnoSeenAt(GCT.Address)">
            <summary>
            Gets the highest seen sequence number
            </summary>
            <param name="sender">Member that the highest seen sequence number is required for</param>
            <returns>Highest seen sequence number</returns>
        </member>
        <member name="M:GCT.Digest.setLowSeqnoAt(System.Int32,System.Int64)">
            <summary>
            Sets the lowest sequence number
            </summary>
            <param name="index">Index to set the lowest seq number</param>
            <param name="low_seqno">New lowest value</param>
        </member>
        <member name="M:GCT.Digest.setHighSeqnoAt(System.Int32,System.Int64)">
            <summary>
            Sets the highest sequence number
            </summary>
            <param name="index">Index to set the highest seq number</param>
            <param name="high_seqno">New highest value</param>
        </member>
        <member name="M:GCT.Digest.setHighSeqnoSeenAt(System.Int32,System.Int64)">
            <summary>
            Sets the highest seen sequence number
            </summary>
            <param name="index">Index to set the highest seen seq number</param>
            <param name="high_seqno_seen">New highest seen value</param>
        </member>
        <member name="M:GCT.Digest.setHighSeqnoAt(GCT.Address,System.Int64)">
            <summary>
            Sets the highest sequence number
            </summary>
            <param name="sender">Member to set the highest seq number for</param>
            <param name="high_seqno">New highest seq number</param>
        </member>
        <member name="M:GCT.Digest.setHighSeqnoSeenAt(GCT.Address,System.Int64)">
            <summary>
            Sets the highest seen sequence number
            </summary>
            <param name="sender">Member to set the highest seen seq number for</param>
            <param name="high_seqno_seen">New highest seen seq number</param>
        </member>
        <member name="M:GCT.Digest.copy">
            <summary>
            Returns a deep-copy of the digest.
            </summary>
            <returns>A deep-copy of the digest</returns>
        </member>
        <member name="M:GCT.Digest.toString">
            <summary>
            Returns a string representation of the Digest
            </summary>
            <returns>A string representation of the Digest</returns>
        </member>
        <member name="M:GCT.Digest.printHighSeqnos">
            <summary>
            Returns all the Highest seq num for each member 
            </summary>
            <returns>All the Highest seq num for each member </returns>
        </member>
        <member name="M:GCT.Digest.printHighSeqnosSeen">
            <summary>
            Returns all the Highest seen seq num for each member 
            </summary>
            <returns>All the Highest seen seq num for each member</returns>
        </member>
        <member name="T:GCT.Protocols.DISCARD">
            <remarks>
            This <c>Protocol</c> should only be used for testing
            </remarks>
            <summary>
            Protocol: Discards up or down messages based on a percentage.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.DISCARD.probUp">
            <summary>
            probability of dropping up msgs
            </summary>
        </member>
        <member name="F:GCT.Protocols.DISCARD.probDown">
            <summary>
            probability of dropping down msgs
            </summary>
        </member>
        <member name="F:GCT.Protocols.DISCARD.excludeItself">
            <summary>
            if true don't discard messages sent/received in this stack
            </summary>
        </member>
        <member name="F:GCT.Protocols.DISCARD.localAddress">
            <summary>
            Local Address
            </summary>
        </member>
        <member name="F:GCT.Protocols.DISCARD.random">
            <summary>
            Used to randomly discard messages.
            </summary>
        </member>
        <member name="M:GCT.Protocols.DISCARD.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:GCT.Protocols.DISCARD.getName">
            <summary>
            Returns unique <c>Protocol</c> name
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.Protocols.DISCARD.setProperties(System.Data.PropertyCollection)">
            <summary>
            Sets the properties specified in the configuration string
            </summary>
            <param name="props">Properties to set</param>
            <returns>False if properties were specified that are not know, otherwise true</returns>
        </member>
        <member name="M:GCT.Protocols.DISCARD.up(GCT.Event)">
            <summary>
            Processes <c>Events</c> traveling up the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.DISCARD.down(GCT.Event)">
            <summary>
            Processes <c>Events</c> traveling down the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="T:GCT.Blocks.DistributedHashtable">
            <remarks>
            
            </remarks>
            <summary>
            Provides a simple distributed hashtable. This class behaves identically to the standard
            system.collections.Hashtable class (e.g. Hashtable[i] = "value" can be used). However, all 
            non-read-only updates will be transmitted to the group. The local hashtables will then be updated
            on receiving the update message.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="T:GCT.MessageListener">
            <summary>
            Allows reception of Messages
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="M:GCT.MessageListener.receive(GCT.Message)">
            <summary>
            Notify the target object of a received Message.
            </summary>
            <param name="msg">Received Message</param>
        </member>
        <member name="F:GCT.Blocks.DistributedHashtable.channel">
            <summary>The channel that will be used for</summary>
        </member>
        <member name="F:GCT.Blocks.DistributedHashtable.ad">
            <summary>Used to automatically retrieved messages from the channel</summary>
        </member>
        <member name="F:GCT.Blocks.DistributedHashtable.listener">
            <summary>Object that will be notified of Add, Remove and Clear operations to the hashtable</summary>
        </member>
        <member name="F:GCT.Blocks.DistributedHashtable.state_mutex">
            <summary>Used to synchronise initial hashtable state</summary>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable.#ctor(GCT.Channel,System.String,GCT.Blocks.DistributedHashtable.Listener)">
            <summary>
            Constructor: Initialises/Connects channel and retreives current hashtable state.
            </summary>
            <param name="channel">The Channel to be used for sharing updates.</param>
            <param name="channelName">Name of channel to connect to.</param>
            <param name="listener">Object that will receive notification of updates.</param>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable.getState">
            <summary>
            Sends a request for the current state. Method returns once response is received.
            </summary>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable.Update(System.Object,System.Object)">
            <summary>
            Updates an entry in the hashtable. Called from "hashtable[key] = value". 
            </summary>
            <param name="key">Key of hashtable entry</param>
            <param name="val">Value of hashtable entry</param>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable.Add(System.Object,System.Object)">
            <summary>
            Adds a value into the Hashtable. This does not update an existing entry.
            </summary>
            <param name="key">Key of hashtable entry</param>
            <param name="val">Value of hashtable entry</param>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable.Clear">
            <summary>
            Clears the hashtable.
            </summary>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable.Remove(System.Object)">
            <summary>
            Removes the specified key from the hashtable.
            </summary>
            <param name="key">Key of hashtable entry</param>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable.Close">
            <summary>
            Closes the associated channel.
            </summary>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable.receive(GCT.Message)">
            <summary>
            Message Listener Implementation. Receives messages from the channel and 
            updates the hashtable accordingly.
            </summary>
            <param name="msg">The received message</param>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable._Add(System.Object,System.Object)">
            <summary>
            Called once remote hashtable Add is required.
            </summary>
            <param name="key">Key of hashtable entry</param>
            <param name="val">Value of hashtable entry</param>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable._Update(System.Object,System.Object)">
            <summary>
            Called once remote hashtable Update is required.
            </summary>
            <param name="key">Key of hashtable entry</param>
            <param name="val">Value of hashtable entry</param>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable._Clear">
            <summary>
            Called once remote hashtable Clear is required.
            </summary>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable._Remove(System.Object)">
            <summary>
            Called once remote hashtable Remove is required.
            </summary>
            <param name="key">Key of hashtable entry</param>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable._State(System.Collections.Hashtable)">
            <summary>
            Called once Set_State message is received. THe current hastable is 
            cleared and the new values inserted.
            </summary>
            <param name="ht">The new Hashtable to install</param>
        </member>
        <member name="P:GCT.Blocks.DistributedHashtable.Item(System.Object)">
            <summary>
            Gets or Sets the value corresponding to the specified key. Setting
            a value causes an update on all hashtables.
            </summary>
        </member>
        <member name="T:GCT.Blocks.DistributedHashtable.Listener">
            <summary>
            Interface for objects that required notification of hashtable changes
            </summary>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable.Listener.entryAdded(System.Object,System.Object)">
            <summary>
            Notification of a added entry.
            </summary>
            <param name="key">Key of hashtable entry</param>
            <param name="val">Value of hashtable entry</param>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable.Listener.entryUpdated(System.Object,System.Object)">
            <summary>
            Notification of an updated entry.
            </summary>
            <param name="key">Key of hashtable entry</param>
            <param name="val">Value of hashtable entry</param>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable.Listener.entryDeleted(System.Object)">
            <summary>
            Notification of a deleted entry.
            </summary>
            <param name="key">Key of hashtable entry</param>
        </member>
        <member name="M:GCT.Blocks.DistributedHashtable.Listener.HTCleared">
            <summary>
            Notification of the hashtable being cleared.
            </summary>
        </member>
        <member name="T:GCT.Blocks.HTUpdate">
            <summary>
            Update for distributed hashtable.
            </summary>
        </member>
        <member name="F:GCT.Blocks.HTUpdate.ADD">
            <summary>Update Type: Add</summary>
        </member>
        <member name="F:GCT.Blocks.HTUpdate.CLEAR">
            <summary>Update Type: Clear</summary>
        </member>
        <member name="F:GCT.Blocks.HTUpdate.REMOVE">
            <summary>Update Type: Remove</summary>
        </member>
        <member name="F:GCT.Blocks.HTUpdate.UPDATE">
            <summary>Update Type: Update</summary>
        </member>
        <member name="F:GCT.Blocks.HTUpdate.GET_STATE">
            <summary>Update Type: Get the full state</summary>
        </member>
        <member name="F:GCT.Blocks.HTUpdate.SET_STATE">
            <summary>Update Type: Set the full state</summary>
        </member>
        <member name="F:GCT.Blocks.HTUpdate.key">
            <summary>Key of modified entry</summary>
        </member>
        <member name="F:GCT.Blocks.HTUpdate.val">
            <summary>Value of modified entry</summary>
        </member>
        <member name="F:GCT.Blocks.HTUpdate.type">
            <summary>Type of modification</summary>
        </member>
        <member name="M:GCT.Blocks.HTUpdate.#ctor(System.Int32,System.Object,System.Object)">
            <remarks> 
            Throws an exception if both key and value are not serializable.
            Depending on the update type either or both variables may be null.
            </remarks>
            <summary>
            Constructor.
            </summary>
            <param name="type">Type of modification</param>
            <param name="key">Key of modified entry</param>
            <param name="val">Value of modified entry</param>
        </member>
        <member name="M:GCT.Blocks.HTUpdate.type2String(System.Int32)">
            <summary>
            Converts the type of modification in to a text representation
            </summary>
            <param name="t">The type of modification</param>
            <returns>String representation of modification type</returns>
        </member>
        <member name="P:GCT.Blocks.HTUpdate.Key">
            <summary>Gets the dictionary key associated with the modification</summary>
        </member>
        <member name="P:GCT.Blocks.HTUpdate.Value">
            <summary>Gets the dictionary value associated with the modification</summary>
        </member>
        <member name="P:GCT.Blocks.HTUpdate.Type">
            <summary>Gets the type of hashtable modification</summary>
        </member>
        <member name="T:GCT.Event">
            <summary>
            Used for intra-stack communication.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Event.MSG">
            <summary>Message Event (Arg = Message)</summary>
        </member>
        <member name="F:GCT.Event.CONNECT">
            <summary>Connect Event (Arg = group name)</summary>
        </member>
        <member name="F:GCT.Event.CONNECT_OK">
            <summary>Reply to Connect Event (Arg = group multicast address)</summary>
        </member>
        <member name="F:GCT.Event.DISCONNECT">
            <summary>Disconnect Event (Arg = member address)</summary>
        </member>
        <member name="F:GCT.Event.DISCONNECT_OK">
            <summary>Reply to Disconnect Event</summary>
        </member>
        <member name="F:GCT.Event.VIEW_CHANGE">
            <summary>View Change Event (Arg = new View)</summary>
        </member>
        <member name="F:GCT.Event.GET_LOCAL_ADDRESS">
            <summary>Get Local Address Event</summary>
        </member>
        <member name="F:GCT.Event.SET_LOCAL_ADDRESS">
            <summary>Set Local Address Event (Arg = local Address)</summary>
        </member>
        <member name="F:GCT.Event.SUSPECT">
            <summary>Suspect Event (Arg = Address of suspected member)</summary>
        </member>
        <member name="F:GCT.Event.FIND_INITIAL_MBRS">
            <summary>Find Initial Members Event</summary>
        </member>
        <member name="F:GCT.Event.FIND_INITIAL_MBRS_OK">
            <summary>Reply to Find Initial Members Event (Arg = ArrayList of PingRsps)</summary>
        </member>
        <member name="F:GCT.Event.TMP_VIEW">
            <summary>Temporary View Event (Arg = new View)</summary>
        </member>
        <member name="F:GCT.Event.BECOME_SERVER">
            <summary>Become Server Event</summary>
        </member>
        <member name="F:GCT.Event.STABLE">
            <summary>Stable Event (Arg = stable Digest)</summary>
        </member>
        <member name="F:GCT.Event.GET_DIGEST">
            <summary>Get Digest Event</summary>
        </member>
        <member name="F:GCT.Event.GET_DIGEST_OK">
            <summary>Reply to Get Digest Event (Arg = Digest)</summary>
        </member>
        <member name="F:GCT.Event.SET_DIGEST">
            <summary>Set Digest Event (Arg = new Digest)</summary>
        </member>
        <member name="F:GCT.Event.EXIT">
            <summary>Exit Event</summary>
        </member>
        <member name="F:GCT.Event.UNSUSPECT">
            <summary>Unsuspect Event (Arg = Address of previously suspected member)</summary>
        </member>
        <member name="F:GCT.Event.MERGE_DIGEST">
            <summary>Merge Digest Event (Arg = Digest to merge)</summary>
        </member>
        <member name="F:GCT.Event.type">
            <summary>
            Current type of event
            </summary>
        </member>
        <member name="F:GCT.Event.arg">
            <summary>
            Object associated with the type
            </summary>
        </member>
        <member name="M:GCT.Event.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="type">Type of Event</param>
        </member>
        <member name="M:GCT.Event.#ctor(System.Int32,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="type">Type of Event</param>
            <param name="arg">Object associated with type</param>
        </member>
        <member name="M:GCT.Event.type2String(System.Int32)">
            <summary>
            Converts an Event type to a string representation
            </summary>
            <param name="t">Type of event</param>
            <returns>A string representatio nof the Event type</returns>
        </member>
        <member name="M:GCT.Event.ToString">
            <summary>
            Returns a string representation of the Event 
            </summary>
            <returns>A string representation of the Event</returns>
        </member>
        <member name="P:GCT.Event.Type">
            <summary>
            Gets and sets the type of the Event
            </summary>
        </member>
        <member name="P:GCT.Event.Arg">
            <summary>
            Gets and sets the object associated with the Event
            </summary>
        </member>
        <member name="T:GCT.Util.QueueClosedException">
            <summary>
            Exception by MQueue when a thread tries to access a closed queue.
            <p><b>Author:</b> Chris Koiak</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="M:GCT.Util.QueueClosedException.#ctor">
            <summary>
            Basic Exception
            </summary>
        </member>
        <member name="M:GCT.Util.QueueClosedException.#ctor(System.String)">
            <summary>
            Exception with custom message
            </summary>
            <param name="msg">Message to display when exception is thrown</param>
        </member>
        <member name="M:GCT.Util.QueueClosedException.toString">
            <summary>
            Creates a String representation of the Exception
            </summary>
            <returns>A String representation of the Exception</returns>
        </member>
        <member name="T:GCT.Util.ChannelNotConnectedException">
            <summary>
            Exception thrown when an action is called on a unconnected Channel
            </summary>
        </member>
        <member name="M:GCT.Util.ChannelNotConnectedException.#ctor">
            <summary>
            Basic Exception
            </summary>
        </member>
        <member name="M:GCT.Util.ChannelNotConnectedException.#ctor(System.String)">
            <summary>
            Exception with custom message
            </summary>
            <param name="msg">Message to display when exception is thrown</param>
        </member>
        <member name="M:GCT.Util.ChannelNotConnectedException.toString">
            <summary>
            Creates a String representation of the Exception
            </summary>
            <returns>A String representation of the Exception</returns>
        </member>
        <member name="T:GCT.Util.ChannelClosedException">
            <summary>
            Exception thrown when an action is called on a closed Channel
            </summary>
        </member>
        <member name="M:GCT.Util.ChannelClosedException.#ctor">
            <summary>
            Basic Exception
            </summary>
        </member>
        <member name="M:GCT.Util.ChannelClosedException.#ctor(System.String)">
            <summary>
            Exception with custom message
            </summary>
            <param name="msg">Message to display when exception is thrown</param>
        </member>
        <member name="M:GCT.Util.ChannelClosedException.toString">
            <summary>
            Creates a String representation of the Exception
            </summary>
            <returns>A String representation of the Exception</returns>
        </member>
        <member name="T:GCT.Protocols.FD">
            <remarks>
            Regularly polls members for
            liveness. Passes SUSPECT message up the stack when a member is not reachable. The simple
            algorithms works as follows: the membership is known and ordered. Each HB protocol
            periodically sends a 'are-you-alive' message to its *neighbor*. A neighbor is the next in
            rank in the membership list. It is recomputed upon a view change. When a response hasn't
            been received for n milliseconds and m tries, the corresponding member is suspected (and
            eventually excluded if faulty).<p>
            FD starts when it detects (in a view change notification) that there are at least
            2 members in the group. It stops running when the membership drops below 2.</p><p>
            When a message is received from the monitored neighbor member, it causes the pinger thread to
            'skip' sending the next are-you-alive message. Thus, traffic is reduced.</p><p>
            When we receive a ping from a member that's not in the membership list, we shun it by sending it a
            NOT_MEMBER message. That member will then leave the group (and possibly rejoin). This is only done if
            <code>shun</code> is true.</p>
            </remarks>
            <summary>
            Protocol: Failure Detection based on simple heartbeat protocol
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.FD.ping_dest">
            <summary>Member to check if active</summary>
        </member>
        <member name="F:GCT.Protocols.FD.local_addr">
            <summary>Local address</summary>
        </member>
        <member name="F:GCT.Protocols.FD.timeout">
            <summary>Number of millisecs to wait for an are-you-alive msg</summary>
        </member>
        <member name="F:GCT.Protocols.FD.last_ack">
            <summary>Time of last acknowledgement</summary>
        </member>
        <member name="F:GCT.Protocols.FD.num_tries">
            <summary>Number of heartbeats still to try before suspecting member</summary>
        </member>
        <member name="F:GCT.Protocols.FD.max_tries">
            <summary>Maximum number of times to send a heartbeat</summary>
        </member>
        <member name="F:GCT.Protocols.FD.members">
            <summary>Current members in the group</summary>
        </member>
        <member name="F:GCT.Protocols.FD.invalid_pingers">
            <summary>Collection of pingers that aren't members (keys=Address, val=int(number of heartbeats received))</summary>
        </member>
        <member name="F:GCT.Protocols.FD.shun">
            <summary>If set, nonmember pingers will be shunned</summary> 
        </member>
        <member name="F:GCT.Protocols.FD.timer">
            <summary>Used to run Monitor tasks</summary> 
        </member>
        <member name="F:GCT.Protocols.FD.monitor">
            <summary>Task that performs the actual monitoring for failure detection</summary> 
        </member>
        <member name="M:GCT.Protocols.FD.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GCT.Protocols.FD.getName">
            <summary>
            Returns unique <c>Protocol</c> name
            </summary>
            <returns>Unique <c>Protocol</c> name</returns>
        </member>
        <member name="M:GCT.Protocols.FD.setProperties(System.Data.PropertyCollection)">
            <summary>
            Sets the properties specified in the configuration string
            </summary>
            <param name="props">Properties to set</param>
            <returns>False if properties were specified that are not know, otherwise true</returns>
        </member>
        <member name="M:GCT.Protocols.FD.getPingDest(System.Collections.ArrayList)">
            <summary>
            Calculate the member that should be checked if alive
            </summary>
            <param name="members">All member in the group</param>
            <returns>The member that should be checked if alive</returns>
        </member>
        <member name="M:GCT.Protocols.FD.up(GCT.Event)">
            <summary>
            Processes <c>Events</c> traveling up the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.FD.down(GCT.Event)">
            <summary>
            Processes <c>Events</c> traveling down the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.FD.init">
            <summary>
            Sets the <c>TimeScheduler</c> to be used to the one present in the <c>ProtocolSinkStack</c>
            </summary>
        </member>
        <member name="M:GCT.Protocols.FD.startMonitor">
            <summary>
            Starts the Monitor task.
            </summary>
        </member>
        <member name="M:GCT.Protocols.FD.stop">
            <summary>
            Stops the Monitor task if its active.
            </summary>
        </member>
        <member name="M:GCT.Protocols.FD.shunInvalidHeartbeatSender(GCT.Address)">
            <summary>
            Shun member pinging this member if it is not a member of the group.
            </summary>
            <param name="hb_sender"></param>
        </member>
        <member name="T:GCT.Protocols.FD.Monitor">
            <summary>
            Internal Class used to sent Heartbeat messages.
            </summary>
        </member>
        <member name="F:GCT.Protocols.FD.Monitor.started">
            <summary>
            Task runs when set.
            </summary>
        </member>
        <member name="M:GCT.Protocols.FD.Monitor.stop">
            <summary>
            Stops the task
            </summary>
        </member>
        <member name="M:GCT.Protocols.FD.Monitor.#ctor(GCT.Protocols.FD)">
            <summary>
            Constructor
            </summary>
            <param name="fd">FD associated with the task</param>
        </member>
        <member name="M:GCT.Protocols.FD.Monitor.getName">
            <summary>
            Returns the name of the task
            </summary>
            <returns>The name of the task</returns>
        </member>
        <member name="M:GCT.Protocols.FD.Monitor.cancelled">
            <summary>
            Checks if the task is cancelled
            </summary>
            <returns>True is the task is cancelled</returns>
        </member>
        <member name="M:GCT.Protocols.FD.Monitor.nextInterval">
            <summary>
            Returns the time until the task should be ran again
            </summary>
            <returns>The time until the task should be ran again</returns>
        </member>
        <member name="M:GCT.Protocols.FD.Monitor.run">
            <summary>
            Sends a Heartbeat to the <i>next</i> member in the group
            </summary>
        </member>
        <member name="T:GCT.Protocols.FdHeader">
            <summary>
            Failure Detection (FD) Header.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.FdHeader.HEARTBEAT">
            <summary>Header Type: Standard Heartbeat</summary>
        </member>
        <member name="F:GCT.Protocols.FdHeader.HEARTBEAT_ACK">
            <summary>Header Type: Standard Heartbeat Acknowledgement</summary>
        </member>
        <member name="F:GCT.Protocols.FdHeader.SUSPECT">
            <summary>Header Type: Suspect a member</summary>
        </member>
        <member name="F:GCT.Protocols.FdHeader.NOT_MEMBER">
            <summary>Header Type: Shun a pinger as they're not in the group</summary>
        </member>
        <member name="F:GCT.Protocols.FdHeader.type">
            <summary>Header Type</summary>
        </member>
        <member name="F:GCT.Protocols.FdHeader.suspected_mbr">
            <summary>Address of suspected pinger</summary>
        </member>
        <member name="F:GCT.Protocols.FdHeader.from">
            <summary>Member who detected suspected pinger</summary>
        </member>
        <member name="M:GCT.Protocols.FdHeader.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="type">Type of FD Header</param>
        </member>
        <member name="M:GCT.Protocols.FdHeader.ToString">
            <summary>
            Returns a string representation of the Header object
            </summary>
            <returns>A string representation of the Header object</returns>
        </member>
        <member name="M:GCT.Protocols.FdHeader.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialises the information
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="context">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="M:GCT.Protocols.FdHeader.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor: Deserialises the information and recreates the instance.
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="ctxt">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="T:GCT.Protocols.GMS">
            <remarks>
            Handles joins/leaves/crashes (suspicions) and emits new views accordingly.
            </remarks>
            <summary>
            Protocol: Group Membership System (GMS) maintains the members in a group.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.GMS.CLIENT">
            <summary>Client implementation string</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.COORD">
            <summary>Coordinator implementation string</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.PART">
            <summary>Participant implementation string</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.impl">
            <summary>Role of the GMS at present</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.local_addr">
            <summary>Local Address</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.group_addr">
            <summary>Group multicast Address</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.members">
            <summary>Membership of group</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.tmp_members">
            <summary>Used for computing new view</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.joining">
            <summary>Members joined but for which no view has been yet</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.view_id">
            <summary>ViewID for current view</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.ltime">
            <summary>Lamport logical time</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.join_timeout">
            <summary>Interval to wait for repsonse to Join</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.join_retry_timeout">
            <summary>Interval to wait before retrying a failed Join</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.leave_timeout">
            <summary>Interval to wait for response to leave</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.digest_timeout">
            <summary>Interval to wait for a response to digest request</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.impl_mutex">
            <summary>Synchronizes event entry into impl</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.digest_mutex">
            <summary>synchronizes the GET_DIGEST/GET_DIGEST_OK events</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.digest">
            <summary>Holds result of last computed digest</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.impls">
            <summary>Collection of Implentations</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.shun">
            <summary>If true then the GMS will leave if not in a new View</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.print_local_addr">
            <summary>Displays the local address when retreived</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.disable_initial_coord">
            <summary>Forces the a join to run continuously until a coodinator is found</summary>
        </member>
        <member name="F:GCT.Protocols.GMS.timer">
            <summary>Used to run tasks</summary>
        </member>
        <member name="M:GCT.Protocols.GMS.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GCT.Protocols.GMS.getName">
            <summary>
            Returns unique <c>Protocol</c> name
            </summary>
            <returns>Unique <c>Protocol</c> name</returns>
        </member>
        <member name="M:GCT.Protocols.GMS.requiredDownServices">
            <summary>
            Required services that must be below this <c>Protocol</c>
            </summary>
            <returns>Required services that must be below this <c>Protocol</c></returns>
        </member>
        <member name="M:GCT.Protocols.GMS.setImpl(GCT.Protocols.GmsImpl)">
            <summary>
            Sets the current GMS implementation
            </summary>
            <param name="new_impl">New GMS implementation</param>
        </member>
        <member name="M:GCT.Protocols.GMS.getImpl">
            <summary>
            Gets the current GMS implementation
            </summary>
            <returns>GMS implementation</returns>
        </member>
        <member name="M:GCT.Protocols.GMS.init">
            <summary>
            Sets the TimeScheduler to the instance in the ProtocolSinkStack and
            initialises the GMS implementation if possible.
            </summary>
        </member>
        <member name="M:GCT.Protocols.GMS.start">
            <summary>
            Starts the GMS implementation.
            </summary>
        </member>
        <member name="M:GCT.Protocols.GMS.stop">
            <summary>
            Stops the GMS implementation.
            </summary>
        </member>
        <member name="M:GCT.Protocols.GMS.becomeCoordinator">
            <summary>
            Sets the GMS implementation to a coordinator
            </summary>
        </member>
        <member name="M:GCT.Protocols.GMS.becomeParticipant">
            <summary>
            Sets the GMS implementation to a participant
            </summary>
        </member>
        <member name="M:GCT.Protocols.GMS.becomeClient">
            <summary>
            Sets the GMS implementation to a client
            </summary>
        </member>
        <member name="M:GCT.Protocols.GMS.haveCoordinatorRole">
            <summary>
            Checks if GMS implementation is a coordinator
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.Protocols.GMS.getNextView(System.Collections.ArrayList,System.Collections.ArrayList,System.Collections.ArrayList)">
            <summary>
            Computes the next view, removes old and suspected members, adds new members.
            </summary>
            <param name="new_mbrs">New members to be added to the view</param>
            <param name="old_mbrs">Old members to be removed from the view</param>
            <param name="suspected_mbrs">Suspected members to be removed from the view</param>
            <returns>The new View</returns>
        </member>
        <member name="M:GCT.Protocols.GMS.castViewChange(System.Collections.ArrayList,System.Collections.ArrayList,System.Collections.ArrayList)">
            <remarks>
            Compute a new view, given the current view, the new members and the suspected/left
             members. Then simply mcast the view to all members. This is different to the VS GMS protocol,
            in which we run a FLUSH protocol which tries to achive consensus on the set of messages mcast in
            the current view before proceeding to install the next view.
            The members for the new view are computed as follows:
            			existing          leaving        suspected          joining
            
            1. new_view      y                 n               n                 y
            2. tmp_view      y                 y               n                 y
            (view_dest)
            <p>
            The new view to be installed includes the existing members plus the joining ones and
            excludes the leaving and suspected members.
            </p>
            A temporary view is sent down the stack as an <em>event</em>. This allows the bottom layer
            (e.g. UDP or TCP) to determine the members to which to send a multicast message. Compared
            to the new view, leaving members are <em>included</em> since they have are waiting for a
            view in which they are not members any longer before they leave. So, if we did not set a
            temporary view, joining members would not receive the view (signalling that they have been
            joined successfully). The temporary view is essentially the current view plus the joining
            members (old members are still part of the current view).
            </remarks>
            <summary>
            Calcualates and multicasts a new view.
            </summary>
            <param name="new_mbrs">New members to be added to the view</param>
            <param name="old_mbrs">Old members to be removed from the view</param>
            <param name="suspected_mbrs">Suspected members to be removed from the view</param>
            <returns>The new View</returns>
        </member>
        <member name="M:GCT.Protocols.GMS.castViewChange(GCT.View)">
            <summary>
            Calls <c>castViewChange(View,Digest), with a null Digest</c>
            </summary>
            <param name="new_view">New View to multicast</param>
        </member>
        <member name="M:GCT.Protocols.GMS.castViewChange(GCT.View,GCT.Digest)">
            <summary>
            Multicasts a new view.
            </summary>
            <param name="new_view">New View to send</param>
            <param name="digest">Digest associated with View</param>
        </member>
        <member name="M:GCT.Protocols.GMS.installView(GCT.View,GCT.Digest)">
            <summary>
            Sets the new view and sends a VIEW_CHANGE event up and down the stack.
            </summary>
            <param name="new_view">New View to install</param>
            <param name="digest">Digest associated with View</param>
        </member>
        <member name="M:GCT.Protocols.GMS.installView(GCT.View)">
            <summary>
            Sets the new view and sends a VIEW_CHANGE event up and down the stack.
            </summary>
            <param name="new_view">New View to install</param>
        </member>
        <member name="M:GCT.Protocols.GMS.determineCoordinator">
            <summary>
            Returns the coordinator of the group (i.e. the first memeber).
            </summary>
            <returns>The coordinator of the group</returns>
        </member>
        <member name="M:GCT.Protocols.GMS.wouldBeNewCoordinator(GCT.Address)">
            <summary>
            Checks whether the potential coordinator would be the new coordinator
            </summary>
            <param name="potential_new_coord">Member to check</param>
            <returns>True if member is second in line</returns>
        </member>
        <member name="M:GCT.Protocols.GMS.checkSelfInclusion(System.Collections.ArrayList)">
            <summary>
            Checks whether this member is a member of the group.
            </summary>
            <param name="mbrs">List of group members</param>
            <returns>True if member is in the group, otherwise false</returns>
        </member>
        <member name="M:GCT.Protocols.GMS.setDigest(GCT.Digest)">
            <summary>
            Send down a SET_DIGEST event 
            </summary>
            <param name="d">Digest to install</param>
        </member>
        <member name="M:GCT.Protocols.GMS.mergeDigest(GCT.Digest)">
            <summary>
            Send down a MERGE_DIGEST event
            </summary>
            <param name="d">Digest to merge</param>
        </member>
        <member name="M:GCT.Protocols.GMS.getDigest">
            <summary>
            Send down a GET_DIGEST event, and wait for a response (GET_DIGEST_OK)
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.Protocols.GMS.up(GCT.Event)">
            <summary>
            Processes <c>Events</c> travelling up the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.GMS.receiveUpEvent(GCT.Event)">
            <remarks>
            This method is overridden to avoid hanging on getDigest(): when a JOIN is received, the coordinator needs
            to retrieve the digest from the PBCAST layer. It therefore sends down a GET_DIGEST event, to which the PBCAST layer
            responds with a GET_DIGEST_OK event.<p>
            However, the GET_DIGEST_OK event will not be processed because the thread handling the JOIN request won't process
            the GET_DIGEST_OK event until the JOIN event returns. The receiveUpEvent() method is executed by the up-handler
            thread of the lower protocol and therefore can handle the event. All we do here is unblock the mutex on which
            JOIN is waiting, allowing JOIN to return with a valid digest. The GET_DIGEST_OK event is then discarded, because
            it won't be processed twice.</p>
            </remarks>
            <summary>
            Intercepts GET_DIGEST_OK Events
            </summary>
            <param name="evt"></param>
        </member>
        <member name="M:GCT.Protocols.GMS.down(GCT.Event)">
            <summary>
            Processes <c>Events</c> traveling down the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.GMS.setProperties(System.Data.PropertyCollection)">
            <summary>
            Sets the properties specified in the configuration string
            </summary>
            <param name="props">Properties to set</param>
            <returns>False if properties were specified that are not know, otherwise true</returns>
        </member>
        <member name="M:GCT.Protocols.GMS.initState">
            <summary>
            Sets the current GMS implementation to Client and resets the viewID
            </summary>
        </member>
        <member name="M:GCT.Protocols.GMS.handleJoinRequest(GCT.Address)">
            <summary>
            Deals with incoming join requests. If we are a coordinator then a response will be sent.
            </summary>
            <param name="mbr"></param>
        </member>
        <member name="M:GCT.Protocols.GMS.sendLeaveResponse(GCT.Address)">
            <summary>
            Acknowledges leave response.
            </summary>
            <param name="mbr"></param>
        </member>
        <member name="M:GCT.Protocols.GMS.printMembers(System.Collections.ArrayList)">
            <summary>
            Returns a String represention and the members in the membership
            </summary>
        </member>
        <member name="T:GCT.Protocols.GmsHeader">
            <summary>
             Group Membership System (GMS) Header.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.GmsHeader.JOIN_REQ">
            <summary>Header Type: Join Request</summary>
        </member>
        <member name="F:GCT.Protocols.GmsHeader.JOIN_RSP">
            <summary>Header Type: Join Response</summary>
        </member>
        <member name="F:GCT.Protocols.GmsHeader.LEAVE_REQ">
            <summary>Header Type: Leave Request</summary>
        </member>
        <member name="F:GCT.Protocols.GmsHeader.LEAVE_RSP">
            <summary>Header Type: Leave Response</summary>
        </member>
        <member name="F:GCT.Protocols.GmsHeader.VIEW">
            <summary>Header Type: View Change</summary>
        </member>
        <member name="F:GCT.Protocols.GmsHeader.type">
            <summary>Header Type.</summary>
        </member>
        <member name="F:GCT.Protocols.GmsHeader.view">
            <summary>Used when type=VIEW</summary>
        </member>
        <member name="F:GCT.Protocols.GmsHeader.mbr">
            <summary>Used when type=JOIN_REQ or LEAVE_REQ</summary>
        </member>
        <member name="F:GCT.Protocols.GmsHeader.join_rsp">
            <summary>Used when type=JOIN_RSP</summary>
        </member>
        <member name="F:GCT.Protocols.GmsHeader.digest">
            <summary>Used when type=VIEW</summary>
        </member>
        <member name="M:GCT.Protocols.GmsHeader.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="type">Type of GMS Header</param>
        </member>
        <member name="M:GCT.Protocols.GmsHeader.#ctor(System.Int32,GCT.View)">
            <summary>
            Constructor
            </summary>
            <param name="type">Type of GMS Header</param>
            <param name="view">View associated with type</param>
        </member>
        <member name="M:GCT.Protocols.GmsHeader.#ctor(System.Int32,GCT.Address)">
            <summary>
            Constructor
            </summary>
            <param name="type">Type of GMS Header</param>
            <param name="mbr">Address associated with type</param>
        </member>
        <member name="M:GCT.Protocols.GmsHeader.#ctor(System.Int32,GCT.Protocols.JoinRsp)">
            <summary>
            Constructor
            </summary>
            <param name="type">Type of GMS Header</param>
            <param name="join_rsp">JoinRsp associated with type</param>
        </member>
        <member name="M:GCT.Protocols.GmsHeader.toString">
            <summary>
            Returns a string representation of the object
            </summary>
            <returns>A string representation of the object</returns>
        </member>
        <member name="M:GCT.Protocols.GmsHeader.type2String(System.Int32)">
            <summary>
            Converts a type into a string represention
            </summary>
            <param name="type">The type required</param>
            <returns>A type into a string represention</returns>
        </member>
        <member name="M:GCT.Protocols.GmsHeader.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialises the information
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="context">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="M:GCT.Protocols.GmsHeader.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor: Deserialises the information and recreates the instance.
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="ctxt">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="T:GCT.GroupChannel">
            <remarks>
            This Channel can be used as a standard group communication channel 
            or as a group extention to the .NET Remoting framework
            
            </remarks>
            <summary>
            Channel for group communication (including .NET Remoting)
            <p><b>Author:</b> Chris Koiak</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.GroupChannel._channelPriority">
            <summary>Priority of Remoting Channel</summary>
        </member>
        <member name="F:GCT.GroupChannel.channel_name">
            <summary>Name of Channel</summary>
        </member>
        <member name="F:GCT.GroupChannel.props">
            <summary>Default Channel properties</summary>
        </member>
        <member name="F:GCT.GroupChannel.prot_stack">
            <summary>Stack of Protocols used to send group messages</summary>
        </member>
        <member name="F:GCT.GroupChannel.my_view">
            <summary>Current membership view</summary>
        </member>
        <member name="F:GCT.GroupChannel.exitEvent">
            <summary>Event sent to upHandler to signify exiting channel</summary>
        </member>
        <member name="F:GCT.GroupChannel.connected">
            <summary>If true, they channel is connected</summary>
        </member>
        <member name="F:GCT.GroupChannel.connect_mutex">
            <summary>Synchronises channel connection</summary>
        </member>
        <member name="F:GCT.GroupChannel.disconnect_mutex">
            <summary>Synchronises channel disconnection</summary>
        </member>
        <member name="F:GCT.GroupChannel.local_addr">
            <summary>Local Address</summary>
        </member>
        <member name="F:GCT.GroupChannel.local_addr_mutex">
            <summary>Synchronises retrieving local address</summary>
        </member>
        <member name="F:GCT.GroupChannel.mq">
            <summary>Queue of messages received</summary>
        </member>
        <member name="F:GCT.GroupChannel.receive_local_msgs">
            <summary>If set, will receive message sent from this member</summary>
        </member>
        <member name="F:GCT.GroupChannel.receive_suspects">
            <summary>If set, will send suspect events to UpHandler</summary>
        </member>
        <member name="F:GCT.GroupChannel.receive_views">
            <summary>If set, will send view events to UpHandler</summary>
        </member>
        <member name="F:GCT.GroupChannel.receive_state_events">
            <summary>If set, will send state events to UpHandler</summary>
        </member>
        <member name="F:GCT.GroupChannel.connectTimeout">
            <summary>Time to wait for reply to disconnect event</summary>
        </member>
        <member name="F:GCT.GroupChannel.disconnectTimeout">
            <summary>Time to wait for reply to disconnect event</summary>
        </member>
        <member name="F:GCT.GroupChannel.LOCAL_ADDR_TIMEOUT">
            <summary>Time to wait for retrieval of local address</summary>
        </member>
        <member name="F:GCT.GroupChannel.closed">
            <summary>If set, channel is closed</summary>
        </member>
        <member name="F:GCT.GroupChannel.responseChooser">
            <summary>Chooses which Remoting response to deliver</summary>
        </member>
        <member name="M:GCT.GroupChannel.#ctor">
            <summary>
            Constructor: Uses default stack
            </summary>
        </member>
        <member name="M:GCT.GroupChannel.#ctor(System.String)">
            <summary>
            Constructor: Uses custom stack and Remoting chooser
            </summary>
            <param name="properties">Custom stack configuration</param>
        </member>
        <member name="M:GCT.GroupChannel.Parse(System.String,System.String@)">
            <summary>
            Returns channelURI and places object uri into out parameter
            </summary>
            <param name="url">The URL to parse</param>
            <param name="objectURI">The object URI</param>
            <returns>The channel URI</returns>
        </member>
        <member name="M:GCT.GroupChannel.CreateMessageSink(System.String,System.Object,System.String@)">
            <summary>
            Returns the ProtocolSinkStack to act as the message sink
            </summary>
            <param name="url"></param>
            <param name="remoteChannelData"></param>
            <param name="objectURI"></param>
            <returns></returns>
        </member>
        <member name="M:GCT.GroupChannel.GetUrlsForUri(System.String)">
            <summary>
            Does nothing.
            </summary>
            <param name="objectURI"></param>
            <returns></returns>
        </member>
        <member name="M:GCT.GroupChannel.StartListening(System.Object)">
            <summary>
            Does nothing.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:GCT.GroupChannel.StopListening(System.Object)">
            <summary>
            Does nothing.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:GCT.GroupChannel.SetupChannel">
            <summary>
            Sets up the ProtocolSinkStack
            </summary>
        </member>
        <member name="M:GCT.GroupChannel.SetupServerChannel">
            <summary>
            Configures the ProtocolSinkStack to communicate received messages with the 
            Remoting infrastructure.
            </summary>
        </member>
        <member name="M:GCT.GroupChannel.up(GCT.Event)">
            <summary>
            Called by the ProtocolSinkStack when messages are recevied.
            </summary>
            <param name="evt">Event that has been received.</param>
        </member>
        <member name="M:GCT.GroupChannel.down(GCT.Event)">
            <summary>
            Sends an Event down the stack
            </summary>
            <param name="evt">Event to send down</param>
        </member>
        <member name="M:GCT.GroupChannel.connect(System.String)">
            <summary>
            Connects the channel the specified group
            </summary>
            <param name="channel_name">Group to connect to.</param>
        </member>
        <member name="M:GCT.GroupChannel.disconnect">
            <summary>
            Disconnect from current group.
            </summary>
        </member>
        <member name="M:GCT.GroupChannel.close">
            <summary>
            Disconnect from the group and close the channel.
            </summary>
        </member>
        <member name="M:GCT.GroupChannel.setOpt(System.String,System.Object)">
            <summary>
            Set configurable options within the channel
            </summary>
            <param name="option">Type of option</param>
            <param name="value">Value of option</param>
        </member>
        <member name="M:GCT.GroupChannel.open">
            <summary>
            Reopen channel after its been closed
            </summary>
        </member>
        <member name="M:GCT.GroupChannel.isOpen">
            <summary>
            Checks if Channel is open
            </summary>
            <returns>True if channel is open, otherwise false</returns>
        </member>
        <member name="M:GCT.GroupChannel.isConnected">
            <summary>
            Checks if Channel is connected
            </summary>
            <returns>True if channel is connected, otherwise false</returns>
        </member>
        <member name="M:GCT.GroupChannel.send(GCT.Message)">
            <summary>
            Sends a message to the group.
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:GCT.GroupChannel.receive(System.Int32)">
            <summary>
            Removes the first received event.
            </summary>
            <param name="timeout">Time to wait on event arriving if all events have been delivered. Setting this less than 0 causes the method to wait indefinately on an event</param>
            <returns>First received event</returns>
        </member>
        <member name="M:GCT.GroupChannel.peek(System.Int32)">
            <summary>
            Peeks at the queue of received events
            </summary>
            <param name="timeout">Time to wait on event arriving if all events have been delivered</param>
            <returns>Event at the front of the queue</returns>
        </member>
        <member name="M:GCT.GroupChannel.getView">
            <summary>
            Returns current View of the group
            </summary>
            <returns>Current View of the group</returns>
        </member>
        <member name="M:GCT.GroupChannel.getLocalAddress">
            <summary>
            Returns local address
            </summary>
            <returns>Local address</returns>
        </member>
        <member name="M:GCT.GroupChannel.getChannelName">
            <summary>
            Returns channel name
            </summary>
            <returns>Channel name</returns>
        </member>
        <member name="M:GCT.GroupChannel.close(System.Boolean,System.Boolean)">
            <remarks>
            This method does the folloing things
            1. Calls <code>this.disconnect</code> if the disconnect parameter is true
            2. Calls <code>Queue.close</code> on mq if the close_mq parameter is true
            3. Calls <code>ProtocolStack.stop</code> on the protocol stack
            4. Calls <code>ProtocolStack.destroy</code> on the protocol stack
            5. Sets the channel closed and channel connected flags to true and false
            6. Notifies any channel listener of the channel close operation
            </remarks>
            <summary>
            Disconnects and closes the channel.
            </summary>
            <param name="disconnect"></param>
            <param name="close_mq"></param>
        </member>
        <member name="M:GCT.GroupChannel.checkClosed">
            <summary>
            Throws Exception if channel is closed
            </summary>
        </member>
        <member name="M:GCT.GroupChannel.checkNotConnected">
            <summary>
            Throws Exception if channel is not connected
            </summary>
        </member>
        <member name="M:GCT.GroupChannel.handleExit(GCT.Event)">
            <summary>
            Delivers exit event to UpHandler.
            </summary>
            <param name="evt"></param>
        </member>
        <member name="M:GCT.GroupChannel.closerThread">
            <summary>
            Delivers exit event to UpHandler.
            </summary>
        </member>
        <member name="P:GCT.GroupChannel.ResponseChooser">
            <summary>
            Gets or sets the RemotingChooser
            </summary>
        </member>
        <member name="P:GCT.GroupChannel.ChannelPriority">
            <summary>
            Gets the priority of the Channel
            </summary>
        </member>
        <member name="P:GCT.GroupChannel.ChannelName">
            <summary>
            Gets the Channel name
            </summary>
        </member>
        <member name="P:GCT.GroupChannel.ChannelData">
            <summary>
            Gets the Data associated with the Channel
            </summary>
        </member>
        <member name="T:GCT.Util.GroupChannelHelper">
            <summary>
            Helper class for Group Channel
            <p><b>Author:</b> Chris Koiak</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Util.GroupChannelHelper._protocolName">
            <summary>
            URI Prefix for this channel
            </summary>
        </member>
        <member name="F:GCT.Util.GroupChannelHelper.s_hostName">
            <summary>Host name of local computer</summary>
        </member>
        <member name="F:GCT.Util.GroupChannelHelper.s_MachineName">
            <summary>Machine name of local computer</summary>
        </member>
        <member name="F:GCT.Util.GroupChannelHelper.s_MachineIp">
            <summary>IP address of local computer</summary>
        </member>
        <member name="M:GCT.Util.GroupChannelHelper.ParseURL(System.String,System.String@)">
            <summary>
            Converts a url into the channel URI and the object URI
            </summary>
            <param name="url">URL to breakdown</param>
            <param name="objectURI">Returning value of obhect URI</param>
            <returns>Channel URI</returns>
        </member>
        <member name="M:GCT.Util.GroupChannelHelper.GetMachineIp">
            <summary>
            Gets the local machine IP Address in string form
            </summary>
            <returns>The local machine IP Address in string form</returns>
        </member>
        <member name="M:GCT.Util.GroupChannelHelper.GetHostName">
            <summary>
            Gets the local host name of the computer
            </summary>
            <returns>The local host name of the computer</returns>
        </member>
        <member name="M:GCT.Util.GroupChannelHelper.GetMachineName">
            <summary>
            Gets the local machine name of the computer
            </summary>
            <returns>The local machine name of the computer</returns>
        </member>
        <member name="T:GCT.Protocols.JoinRsp">
            <summary>
            Response to join request from GMS.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.JoinRsp.view">
            <summary>Current view of the group</summary>
        </member>
        <member name="F:GCT.Protocols.JoinRsp.digest">
            <summary>Current digest of the group</summary>
        </member>
        <member name="M:GCT.Protocols.JoinRsp.#ctor(GCT.View,GCT.Digest)">
            <summary>
            Constructor.
            </summary>
            <param name="view">Current view of the group</param>
            <param name="digest">Current digest of the group</param>
        </member>
        <member name="M:GCT.Protocols.JoinRsp.getView">
            <summary>Gets the returned View</summary>
        </member>
        <member name="M:GCT.Protocols.JoinRsp.getDigest">
            <summary>Gets the returned Digest</summary>
        </member>
        <member name="M:GCT.Protocols.JoinRsp.toString">
            <summary>
            Returns a string representation of the current object
            </summary>
            <returns>A string representation of the current object</returns>
        </member>
        <member name="T:GCT.Membership">
            <remarks>
            Coupled with an <c>ArrayList</c>, this class extends its facilites  and adds
            extra constraints
            </remarks>
            <summary>
            Used by the GMS to store the current members in the group
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Membership.members">
            <summary>
            List of current members
            </summary>
        </member>
        <member name="M:GCT.Membership.#ctor">
            <summary>
            Constructor: Initialises with no initial members
            </summary>
        </member>
        <member name="M:GCT.Membership.#ctor(System.Collections.ArrayList)">
            <summary>
            Constructor: Initialises with the specified initial members 
            </summary>
            <param name="initial_members">Initial members of the membership</param>
        </member>
        <member name="M:GCT.Membership.getMembers">
            <summary>
            Returns a clone of the members list
            </summary>
            <returns>A clone of the members list</returns>
        </member>
        <member name="M:GCT.Membership.setMembers(System.Collections.ArrayList)">
            <summary>
            Sets the members to the specified list
            </summary>
            <param name="membrs">The current members</param>
        </member>
        <member name="M:GCT.Membership.add(GCT.Address)">
            <remarks>
            If the member already exists then the member will
            not be added to the membership
            </remarks>
            <summary>
            Adds a new member to this membership.
            </summary>
            <param name="new_member"></param>
        </member>
        <member name="M:GCT.Membership.add(System.Collections.ArrayList)">
            <summary>
            Adds a number of members to this membership
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:GCT.Membership.remove(GCT.Address)">
            <summary>
            Removes the specified member
            </summary>
            <param name="old_member">Member that has left the group</param>
        </member>
        <member name="M:GCT.Membership.remove(System.Collections.ArrayList)">
            <summary>
            Removes a number of members from the membership
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:GCT.Membership.clear">
            <summary>
            Removes all members
            </summary>
        </member>
        <member name="M:GCT.Membership.set(System.Collections.ArrayList)">
            <summary>
            Sets the membership to the members present in the list
            </summary>
            <param name="v">New list of members</param>
        </member>
        <member name="M:GCT.Membership.set(GCT.Membership)">
            <summary>
            Sets the membership to the specified membership
            </summary>
            <param name="m">New membership</param>
        </member>
        <member name="M:GCT.Membership.contains(GCT.Address)">
            <summary>
            Returns true if the provided member belongs to this membership
            </summary>
            <param name="member">Member to check</param>
            <returns>True if the provided member belongs to this membership, otherwise false</returns>
        </member>
        <member name="M:GCT.Membership.copy">
            <summary>
            Returns a copy of this membership.
            </summary>
            <returns>A copy of this membership</returns>
        </member>
        <member name="M:GCT.Membership.Clone">
            <summary>
            Clones the membership
            </summary>
            <returns>A clone of the membership</returns>
        </member>
        <member name="M:GCT.Membership.size">
            <summary>
            The number of members in the membership
            </summary>
            <returns>Number of members in the membership</returns>
        </member>
        <member name="M:GCT.Membership.elementAt(System.Int32)">
            <summary>
            Gets a member at a specified index
            </summary>
            <param name="index">Index of member</param>
            <returns>Address of member</returns>
        </member>
        <member name="M:GCT.Membership.toString">
            <summary>
            String representation of the Membership object
            </summary>
            <returns>String representation of the Membership object</returns>
        </member>
        <member name="T:GCT.MembershipListener">
            <summary>
            Allows reception of Membership changes
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="M:GCT.MembershipListener.viewAccepted(GCT.View)">
            <summary>
            Notify the target object of a change of membership.
            </summary>
            <param name="new_view">New view of group</param>
        </member>
        <member name="M:GCT.MembershipListener.suspect(GCT.Address)">
            <summary>
            Notify the target object of a suspected member
            </summary>
            <param name="suspected_mbr"></param>
        </member>
        <member name="T:GCT.Message">
            <remarks>
            A Message encapsulates data sent to members of a group. 
            It contains among other things the address of the sender, 
            the destination address, a payload (byte buffer) and a list of 
            headers. Headers are added by protocols on the sender side and 
            removed by protocols on the receiver's side.
            </remarks>
            <summary>
            Message passed between members of a group.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Message.dest_addr">
            <summary>Destination of the message</summary>
        </member>
        <member name="F:GCT.Message.src_addr">
            <summary>Source of the message</summary>
        </member>
        <member name="F:GCT.Message.buf">
            <summary>Byte buffer of payload associated with the message</summary>
        </member>
        <member name="F:GCT.Message.headers">
            <summary>Headers added to the message</summary>
        </member>
        <member name="M:GCT.Message.#ctor(GCT.Address,GCT.Address,System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="dest">Destination of the message</param>
            <param name="src">Source of the message</param>
            <param name="buf">Byte buffer of payload associated with the message</param>
        </member>
        <member name="M:GCT.Message.#ctor(GCT.Address,GCT.Address,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="dest">Destination of the message</param>
            <param name="src">Source of the message</param>
            <param name="obj">Serialisable payload OR array of <c>Message</c>s</param>
        </member>
        <member name="M:GCT.Message.Equals(System.Object)">
            <summary>
            Compares a second <c>Message</c> for equality
            </summary>
            <param name="obj">Second Message object</param>
            <returns>True if Messages are equal</returns>
        </member>
        <member name="M:GCT.Message.GetHashCode">
            <summary>
            Returns the hash value for a Message
            </summary>
            <returns>The hash value for a Message</returns>
        </member>
        <member name="M:GCT.Message.setObject(System.Object)">
            <summary>
            Serialises an object in to the payload
            </summary>
            <param name="obj">Object to serialise</param>
        </member>
        <member name="M:GCT.Message.getObject">
            <summary>
            Deserialises an Object from the payload
            </summary>
            <returns>Deserialised Object</returns>
        </member>
        <member name="M:GCT.Message.setMessageArray(System.Array)">
            <remarks>
            This is used by the NAKACK layer to send multiple missed messages. 
            The alternative is to sent each missed message one at a time.
            </remarks>
            <summary>
            Writes an array of messages into the payload.
            </summary>
            <param name="obj">Array of Message objects</param>
        </member>
        <member name="M:GCT.Message.getMessageArray">
            <summary>
            Deserialises an array of Messages from the payload
            </summary>
            <returns>An array of Messages </returns>
        </member>
        <member name="M:GCT.Message.WriteInt64(System.Int64)">
            <summary>
            Creates a byte buffer representation of a <c>long</c>
            </summary>
            <param name="value"><c>long</c> to be converted</param>
            <returns>Byte Buffer representation of a <c>long</c></returns>
        </member>
        <member name="M:GCT.Message.convertToLong(System.Byte[])">
            <summary>
            Creates a <c>long</c> from a byte buffer representation
            </summary>
            <param name="_byteBuffer">Byte Buffer representation of a <c>long</c></param>
            <returns></returns>
        </member>
        <member name="M:GCT.Message.copy">
            <summary>
            Copy the Message
            </summary>
            <returns>A copy of the current Message</returns>
        </member>
        <member name="M:GCT.Message.size">
            <remarks>
            Quite an expensive method as it has to serialise the message to 
            get the size of it. It's use should be limited
            </remarks>
            <summary>
            Serialised size of the message
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.Message.putHeader(System.String,GCT.Header)">
            <summary>
            Adds a header in to the Message
            </summary>
            <param name="key">Protocol Name associated with the header</param>
            <param name="hdr">Implementation of the Header class</param>
        </member>
        <member name="M:GCT.Message.removeHeader(System.String)">
            <summary>
            Removes a header associated with a Protocol layer
            </summary>
            <param name="key">Protocol Name associated with the header</param>
            <returns>Implementation of the Header class</returns>
        </member>
        <member name="M:GCT.Message.removeHeaders">
            <summary>
            Clears all Headers from message
            </summary>
        </member>
        <member name="M:GCT.Message.getHeader(System.String)">
            <summary>
            Gets a header associated with a Protocol layer
            </summary>
            <param name="key">Protocol Name associated with the header</param>
            <returns>Implementation of the Header class</returns>
        </member>
        <member name="M:GCT.Message.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialises the message. Called by the <c>BinaryFormatter</c>.
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="context">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="M:GCT.Message.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor: used for deserialization
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="ctxt">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="P:GCT.Message.Destination">
            <summary>
            Gets and sets the destination of the message
            </summary>
        </member>
        <member name="P:GCT.Message.Source">
            <summary>
            Gets and sets the source of the message
            </summary>
        </member>
        <member name="P:GCT.Message.Buffer">
            <summary>
            Gets and sets the payload (bute buffer) of the message
            </summary>
        </member>
        <member name="P:GCT.Message.Headers">
            <summary>
            Gets the collection of Headers added to the message
            </summary>
        </member>
        <member name="T:GCT.Util.MQueue">
            <summary>
            Wrapper class of <c>Queue</c>. Extends operations by allowing remove and peek
            operations to have timeouts
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Util.MQueue.closed">
            <summary>If <c>MQueue</c> is closed then no messages can be removed.</summary>
        </member>
        <member name="F:GCT.Util.MQueue.q">
            <summary>Internal <c>Queue</c></summary>
        </member>
        <member name="M:GCT.Util.MQueue.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GCT.Util.MQueue.Add(System.Object)">
            <summary>
            Adds an object to the queue
            </summary>
            <param name="obj">Object to add to the queue</param>
        </member>
        <member name="M:GCT.Util.MQueue.Remove(System.Int32)">
            <summary>
            Removes the first element in the queue.
            </summary>
            <param name="timeout">Time to wait for an element in the queue</param>
            <returns>The first element or <c>null</c> if timeout expired</returns>
        </member>
        <member name="M:GCT.Util.MQueue.Remove">
            <summary>
            Removes the first element in the queue. Waits indefinately for an element to arrive
            </summary>
            <returns>The first element in the queue.</returns>
        </member>
        <member name="M:GCT.Util.MQueue.peek(System.Int32)">
            <summary>
            Returns the first element in the queue.
            </summary>
            <param name="timeout">Time to wait for an element in the queue</param>
            <returns>The first element or <c>null</c> if timeout expired</returns>
        </member>
        <member name="M:GCT.Util.MQueue.close">
            <summary>
            Closes access to the queue
            </summary>
        </member>
        <member name="M:GCT.Util.MQueue.reset">
            <summary>
            Closes the queue, clears all elements and then opens the queue for access
            </summary>
        </member>
        <member name="P:GCT.Util.MQueue.Count">
            <summary>
            Number of Objects in the queue
            </summary>
        </member>
        <member name="P:GCT.Util.MQueue.Closed">
            <summary>
            Gets and sets the access state of the queue 
            </summary>
        </member>
        <member name="T:GCT.Protocols.NAKACK">
            <remarks>
            Messages are assigned a monotonically increasing sequence number (seqno).
            Receivers deliver messages ordered according to seqno and request retransmission of missing messages. Retransmitted
            messages are bundled into bigger ones, e.g. when getting an xmit request for messages 1-10, instead of sending 10
            unicast messages, we bundle all 10 messages into 1 and send it. 
            We only bundle messages up to max_xmit_size bytes to prevent too large messages. For example, if the bundled message
            size was a total of 34000 bytes, and max_xmit_size=16000, we'd send 3 messages: 2 16K and a 2K message.
            </remarks>
            <summary>
            Protocol: Multicast Negative AcKnowledgement layer (NAK)
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.NAKACK.retransmit_timeout">
            <summary>Interval to wait before requesting retransmission</summary>
        </member>
        <member name="F:GCT.Protocols.NAKACK.is_server">
            <summary>If set, process is a member of a group</summary>
        </member>
        <member name="F:GCT.Protocols.NAKACK.local_addr">
            <summary>Local <c>Address</c></summary>
        </member>
        <member name="F:GCT.Protocols.NAKACK.members">
            <summary>Current members in the group</summary>
        </member>
        <member name="F:GCT.Protocols.NAKACK.seqno">
            <summary>Current message sequence number (starts with 0)</summary> 
        </member>
        <member name="F:GCT.Protocols.NAKACK.deleted_up_to">
            <summary>Keeps track of lowest sequence number garbage collected</summary>
        </member>
        <member name="F:GCT.Protocols.NAKACK.max_xmit_size">
            <summary>Maximum size of a retransmit message</summary>
        </member>
        <member name="F:GCT.Protocols.NAKACK.gc_lag">
            <summary>Number of msgs garbage collection lags behind</summary>
        </member>
        <member name="F:GCT.Protocols.NAKACK.received_msgs">
            <summary>Holds senders and their associated NakReceiverWindows</summary>
        </member>
        <member name="F:GCT.Protocols.NAKACK.sent_msgs">
            <summary>Holds sent message sequence numbers and the associated message</summary>
        </member>
        <member name="F:GCT.Protocols.NAKACK.leaving">
            <summary>If set then currently disconnecting from the group</summary>
        </member>
        <member name="F:GCT.Protocols.NAKACK.timer">
            <summary>Used for running tasks.</summary>
        </member>
        <member name="M:GCT.Protocols.NAKACK.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GCT.Protocols.NAKACK.getName">
            <summary>
            Returns unique <c>Protocol</c> name
            </summary>
            <returns>Unique <c>Protocol</c> name</returns>
        </member>
        <member name="M:GCT.Protocols.NAKACK.providedUpServices">
            <summary>
            Provided services for layers below NAKACK
            </summary>
            <returns>List of provided service</returns>
        </member>
        <member name="M:GCT.Protocols.NAKACK.providedDownServices">
            <summary>
            Provided services for layers above NAKACK
            </summary>
            <returns>List of provided services</returns>
        </member>
        <member name="M:GCT.Protocols.NAKACK.start">
            <summary>
            Uses TimeScheduler from ProtocolSinkStack.
            </summary>
        </member>
        <member name="M:GCT.Protocols.NAKACK.stop">
            <summary>
            Stops any running tasks
            </summary>
        </member>
        <member name="M:GCT.Protocols.NAKACK.down(GCT.Event)">
            <summary>
            Processes <c>Events</c> traveling down the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.NAKACK.up(GCT.Event)">
            <summary>
            Processes <c>Events</c> travelling up the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.NAKACK.setProperties(System.Data.PropertyCollection)">
            <summary>
            Sets the properties specified in the configuration string
            </summary>
            <param name="props">Properties to set</param>
            <returns>False if properties were specified that are not know, otherwise true</returns>
        </member>
        <member name="M:GCT.Protocols.NAKACK.getNextSeqno">
            <summary>
            Increments and returns the current sequence number
            </summary>
            <returns>The next sequence number</returns>
        </member>
        <member name="M:GCT.Protocols.NAKACK.send(GCT.Message)">
            <summary>
            Adds the message to the sent_msgs table and then passes it down the stack.
            </summary>
            <param name="msg">The message to be sent</param>
        </member>
        <member name="M:GCT.Protocols.NAKACK.handleMessage(GCT.Message,GCT.Protocols.NakAckHeader)">
            <remarks>
            Finds the corresponding NakReceiverWindow and adds the message to it (according to seqno). Then removes
            as many messages as possible from the NRW and passes them up the stack. Discards messages from non-members.
            </remarks>
            <summary>
            Results in all possible messages from sender being delivered up the stacks
            </summary>
            <param name="msg"></param>
            <param name="hdr"></param>
        </member>
        <member name="M:GCT.Protocols.NAKACK.handleXmitReq(GCT.Address,System.Int64,System.Int64)">
            <remarks>
            Retransmit from sent-table, called when XMIT_REQ is received. Bundles all messages to be xmitted into
            one large message and sends them back with an XMIT_RSP header. Note that since we cannot count on a
            fragmentation layer below us, we have to make sure the message doesn't exceed max_xmit_size bytes. If
            this is the case, we split the message into multiple, smaller-chunked messages. But in most cases this
            still yields fewer messages than if each requested message was retransmitted separately.
            </remarks>
            <summary>
            Retransmits all the missing messages.
            </summary>
            <param name="dest"></param>
            <param name="first_seqno"></param>
            <param name="last_seqno"></param>
        </member>
        <member name="M:GCT.Protocols.NAKACK.sendXmitRsp(GCT.Message,System.Int64,System.Int64)">
            <summary>
            Sends a XMIT_RSP message
            </summary>
            <param name="msg">Message containing missing messages</param>
            <param name="first_seqno">First sequence number of missing messages</param>
            <param name="last_seqno">Last sequence number of missing messages</param>
        </member>
        <member name="M:GCT.Protocols.NAKACK.handleXmitRsp(GCT.Message)">
            <summary>
            Delivers all received messages from XMIT_RSP 
            </summary>
            <param name="msg">XMIT_RSP Message</param>
        </member>
        <member name="M:GCT.Protocols.NAKACK.adjustReceivers">
            <summary>
            Removes all old members and creates NakReceiverWindows for all new members
            </summary>
        </member>
        <member name="M:GCT.Protocols.NAKACK.getDigest">
            <summary>
            Returns a message digest
            </summary>
        </member>
        <member name="M:GCT.Protocols.NAKACK.getDigestHighestDeliveredMsgs">
            <remarks>
            Returns a message digest: for each member P the highest seqno received from P <em>without a gap</em>
            is added to the digest. E.g. if the seqnos received from P are [+3 +4 +5 -6 +7 +8], then 5 will be returned.
            Also, the highest seqno <em>seen</em> is added. The max of all highest seqnos seen will be used (in STABLE)
            to determine whether the last seqno from a sender was received).
            </remarks>
            <summary>
            Returns a message digest.
            </summary>
        </member>
        <member name="M:GCT.Protocols.NAKACK.setDigest(GCT.Digest)">
            <summary>
            Installs new NakReceiverWindows with the values specified in the Digest.
            </summary>
            <param name="d"></param>
        </member>
        <member name="M:GCT.Protocols.NAKACK.mergeDigest(GCT.Digest)">
            <remarks>
            For all members of the digest, adjust the NakReceiverWindows in the received_msgs hashtable.
            If the member already exists, sets its seqno to be the max of the seqno and the seqno of the member
            in the digest. If no entry exists, create one with the initial seqno set to the seqno of the
            member in the digest.
            </remarks>
            <summary>
            Merges two digests together
            </summary>
            <param name="d">Digest to merge</param>
        </member>
        <member name="M:GCT.Protocols.NAKACK.getLowestAndHighestSeqno(GCT.Address,System.Boolean)">
            <remarks>
            Returns the lowest seqno still in cache (so it can be retransmitted) and the highest seqno received so far.
            <p>
            If <c>stop_at_gaps</c> is true, the highest seqno *deliverable* will be returned. If false, the highest seqno 
            *received* will be returned. E.g. for [+3 +4 +5 -6 +7 +8], the highest_seqno_received is 8,
            whereas the higheset_seqno_seen (deliverable) is 5.
            </p>
            </remarks>
            <summary>
            Returns the Digest range for a sender
            </summary>
            <param name="sender">The address for which the highest and lowest seqnos are to be retrieved</param>
            <param name="stop_at_gaps">See Remarks</param>
            <returns>Range of sequence numbers</returns>
        </member>
        <member name="M:GCT.Protocols.NAKACK.getHighSeqnoSeen(GCT.Address)">
            <summary>
            Returns the highest seqno seen from sender. 
            </summary>
            <param name="sender">The address for which the highest seqno is to be retrieved</param>
            <returns>Highest seen sequence number</returns>
        </member>
        <member name="M:GCT.Protocols.NAKACK.stable(GCT.Digest)">
            <remarks>
            Garbage collect all messages less than or equal to seqno at digest[P]. Update received_msgs:
            for each sender P in the digest and its highest seqno seen SEQ, garbage collect all delivered_msgs in the
             NakReceiverWindow corresponding to P.
            </remarks>
            <summary>
            Garbage collect messages that have been seen by all members.
            </summary>
            <param name="d"></param>
        </member>
        <member name="M:GCT.Protocols.NAKACK.retransmit(System.Int64,System.Int64,GCT.Address)">
            <summary>
            Implementation of Retransmitter.RetransmitCommand, sends XMIT_REQ to originator of message
            </summary>
            <param name="first_seqno">First sequence number missing</param>
            <param name="last_seqno">Last sequence number missing</param>
            <param name="sender">Origin of the message</param>
        </member>
        <member name="M:GCT.Protocols.NAKACK.clear">
            <summary>
            Resets NAKACK and resets the NakReceiverWindow of each sender
            </summary>
        </member>
        <member name="M:GCT.Protocols.NAKACK.removeAll">
            <summary>
            Resets NAKACK and destorys the NakReceiverWindow of each sender
            </summary>
        </member>
        <member name="M:GCT.Protocols.NAKACK.printSentMsgs">
            <summary>
            Returns a string representation of the sent messages.
            </summary>
        </member>
        <member name="T:GCT.Protocols.NakAckHeader">
            <summary>
            NACACK Header
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.NakAckHeader.MSG">
            <summary>Header Type: Regular multicast message</summary>
        </member>
        <member name="F:GCT.Protocols.NakAckHeader.XMIT_REQ">
            <summary>Header Type: Retransmit request message</summary>
        </member>
        <member name="F:GCT.Protocols.NakAckHeader.XMIT_RSP">
            <summary>Header Type: Retransmit response message</summary>
        </member>
        <member name="F:GCT.Protocols.NakAckHeader.type">
            <summary>Header Type</summary>
        </member>
        <member name="F:GCT.Protocols.NakAckHeader.seqno">
            <summary>Sequence number of regular message</summary>
        </member>
        <member name="F:GCT.Protocols.NakAckHeader.range">
            <summary>Range of messages that need transmission</summary>
        </member>
        <member name="M:GCT.Protocols.NakAckHeader.#ctor(System.Int32,System.Int64)">
            <summary>
            Constructor: Used for regular messages
            </summary>
            <param name="type">Header type (i.e. MSG)</param>
            <param name="seqno">Sequence number of message</param>
        </member>
        <member name="M:GCT.Protocols.NakAckHeader.#ctor(System.Int32,System.Int64,System.Int64)">
            <summary>
            Constructor: Used for retransmit requests/responses
            </summary>
            <param name="type">Header type (i.e. XMIT_REQ/XMIT_RSP)</param>
            <param name="low">Lowest message needing retransmission</param>
            <param name="high">Highest message needing retransmission</param>
        </member>
        <member name="M:GCT.Protocols.NakAckHeader.type2Str(System.Int32)">
            <summary>
            Returns a string representation of the Header type
            </summary>
            <param name="t">Type of Header</param>
            <returns>String representation</returns>
        </member>
        <member name="M:GCT.Protocols.NakAckHeader.toString">
            <summary>
            Returns a string representation of the Header object
            </summary>
            <returns>A string representation of the Header object</returns>
        </member>
        <member name="M:GCT.Protocols.NakAckHeader.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialises the information
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="context">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="M:GCT.Protocols.NakAckHeader.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor: Deserialises the information and recreates the instance.
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="ctxt">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="T:GCT.Stack.NakReceiverWindow">
            <remarks>
            Keeps track of messages according to their sequence numbers. Allows
            messages to be added out of order, and with gaps between sequence numbers.
            Method <code>remove()</code> removes the first message with a sequence
            number that is 1 higher than <code>next_to_remove</code> (this variable is
            then incremented), or it returns null if no message is present, or if no
            message's sequence number is 1 higher.
            <p>
            When there is a gap upon adding a message, its seqno will be added to the 
            Retransmitter, which (using a timer) requests retransmissions of missing
            messages and keeps on trying until the message has been received, or the
            member who sent the message is suspected.
            </p>
            </remarks>
            <summary>
            Negative Acknowledgement receiver window. Detects gaps and request retransmission.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Stack.NakReceiverWindow.sender">
            <summary>The sender that this window is associated with</summary>
        </member>
        <member name="F:GCT.Stack.NakReceiverWindow.rwlock">
            <summary>Maintains synchronisation throughout the window</summary>
        </member>
        <member name="F:GCT.Stack.NakReceiverWindow.head">
            <summary>Keep track of *next* seqno to remove and highest received</summary>
        </member>
        <member name="F:GCT.Stack.NakReceiverWindow.tail">
            <summary>Last seqno received</summary>
        </member>
        <member name="F:GCT.Stack.NakReceiverWindow.lowest_seen">
            <summary>lowest seqno delivered so far</summary>
        </member>
        <member name="F:GCT.Stack.NakReceiverWindow.highest_seen">
            <summary>highest deliverable (or delivered) seqno so far</summary>
        </member>
        <member name="F:GCT.Stack.NakReceiverWindow.msgs">
            <summary>List received Entrys (i.e. seqno + message)</summary>
        </member>
        <member name="F:GCT.Stack.NakReceiverWindow.delivered_msgs">
            <summary>Messages delivered; list of Entries</summary>
        </member>
        <member name="F:GCT.Stack.NakReceiverWindow.cmd">
            <summary>Method to call for retransmission</summary>
        </member>
        <member name="F:GCT.Stack.NakReceiverWindow.retransmitter">
            <summary>Retransmitter of missing messages</summary>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.#ctor(GCT.Address,GCT.Stack.Retransmitter.RetransmitCommand,System.Int64,GCT.Util.TimeScheduler)">
            <summary>
            Constructor: Creates a new instance with the given retransmit command
            </summary>
            <param name="sender">The sender associated with this instance</param>
            <param name="cmd">The command used to retransmit a missing message</param>
            <param name="start_seqno">The first sequence number to be received</param>
            <param name="sched">The external scheduler to use for retransmission</param>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.#ctor(GCT.Address,GCT.Stack.Retransmitter.RetransmitCommand,System.Int64)">
            <summary>
            Constructor: Creates a new instance with the given retransmit command
            </summary>
            <param name="sender">The sender associated with this instance</param>
            <param name="cmd">The command used to retransmit a missing message</param>
            <param name="start_seqno">The first sequence number to be received</param>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.setRetransmitTimeouts(System.Int64[])">
            <summary>
            Sets the invervals between retransmit requests
            </summary>
            <param name="timeouts">Invervals between retransmit requests</param>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.add(System.Int64,GCT.Message)">
            <remarks>
            Variables <code>head</code> and <code>tail</code> mark the start and
            end of the messages received, but not delivered yet. When a message is
            received, if its seqno is smaller than <code>head</code>, it is
            discarded (already received). If it is bigger than <code>tail</code>,
            we advance <code>tail</code> and add empty elements. If it is between
            <code>head</code> and <code>tail</code>, we set the corresponding
            missing (or already present) element. If it is equal to
            <code>tail</code>, we advance the latter by 1 and add the message
            (default case).
            </remarks>
            <summary>
            Adds a message according to its sequence number.
            </summary>
            <param name="seqno">Sequence number of the message.</param>
            <param name="msg">Message to add.</param>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.remove">
            <summary>
            Returns the next received message.
            </summary>
            <returns>The next received message. May return null indicating a gap</returns>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.stable(System.Int64)">
            <remarks>
            A message is stable when it has been received by all members
            </remarks>
            <summary>
            Deletes all messages that are less than the seqno.
            </summary>
            <param name="seqno"></param>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.reset">
            <summary>
            Reset the retransmitter and the nak window
            </summary>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.destroy">
            <summary>
            Stop the retransmitter and reset the nak window
            </summary>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.getHighestDelivered">
            <summary>
            Return the highest sequence number of a message consumed by the application
            </summary>
            <returns>The highest sequence number of a message consumed by the application</returns>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.getLowestSeen">
            <summary>
            Returns the lowest sequence number of a message that has been
            delivered or is a candidate for delivery
            </summary>
            <returns>The lowest sequence number of a message that has been
            delivered or is a candidate for delivery</returns>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.getHighestSeen">
            <summary>
            Returns the highest deliverable seqno
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.getMissingMessages(System.Int64,System.Int64)">
            <summary>
            Find all messages between, and including, 'low' and 'high' that have a null msg.
            </summary>
            <param name="low">Lowest seqno of interest</param>
            <param name="high">Highest seqno of interest</param>
            <returns>A list of integers, sorted in ascending order.</returns>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.getHighestReceived">
            <remarks>
            Returns the highest sequence number received so far (which may be
            higher than the highest seqno <em>delivered</em> so far, e.g. for
            1,2,3,5,6 it would be 6
            </remarks>
            <summary>
            Returns the highest sequence number received so far.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.size">
            <summary>
            Number of messages received
            </summary>
            <returns>Number of messages received</returns>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.toString">
            <summary>
            String representation of the Receiver Window
            </summary>
            <returns>String representation of the Receiver Window</returns>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow._updateLowestSeen">
            <summary>
            Updates the lowest seen sequence number
            </summary>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow._updateHighestSeen">
            <remarks>
            Find the highest seqno that is deliverable or was actually delivered.
            Returns seqno-1 if there are no messages in the queues (the first
            message to be expected is always seqno).
            </remarks>
            <summary>
            Updates the highest seen sequence number
            </summary>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow._reset">
            <remarks>
            <list type="">
            <item>i. Delete all received entries</item>
            <item>ii. Delete alll delivered entries</item>
            <item>Reset all indices (head, tail, etc.)</item>
            </list>
            </remarks>
            <summary>
            Reset the Nak window.
            </summary>
        </member>
        <member name="T:GCT.Stack.NakReceiverWindow.Entry">
            <summary>
            Maintains association between sequence number and message
            </summary>
        </member>
        <member name="F:GCT.Stack.NakReceiverWindow.Entry.seqno">
            <summary>Sequence number</summary>
        </member>
        <member name="F:GCT.Stack.NakReceiverWindow.Entry.msg">
            <summary>Associated Message</summary>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.Entry.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.Entry.#ctor(System.Int64,GCT.Message)">
            <summary>
            Constructor
            </summary>
            <param name="seqno">Sequence number</param>
            <param name="msg">Associated Message</param>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.Entry.copy">
            <summary>
            Returns a deep-copy of the Entry
            </summary>
            <returns>A deep-copy of the Entry</returns>
        </member>
        <member name="M:GCT.Stack.NakReceiverWindow.Entry.toString">
            <summary>
            Returns a string representation of the Entry
            </summary>
            <returns>A string representation of the Entry</returns>
        </member>
        <member name="T:GCT.Protocols.ParticipantGmsImpl">
            <summary>
            Participant role of the GMS protocol.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.ParticipantGmsImpl.leaving">
            <summary>Indicates if the member is currently leaving </summary>
        </member>
        <member name="F:GCT.Protocols.ParticipantGmsImpl.suspected_mbrs">
            <summary>List of suspected members</summary>
        </member>
        <member name="F:GCT.Protocols.ParticipantGmsImpl.leave_promise">
            <summary>Used to wait for leave response</summary>
        </member>
        <member name="F:GCT.Protocols.ParticipantGmsImpl.leaveRsp">
            <summary>If true, leave response was received</summary>
        </member>
        <member name="M:GCT.Protocols.ParticipantGmsImpl.#ctor(GCT.Protocols.GMS)">
            <summary>
            Constructor
            </summary>
            <param name="g">GMS Protocol using this implementation</param>
        </member>
        <member name="M:GCT.Protocols.ParticipantGmsImpl.join(GCT.Address)">
            <summary>
            Not implemented by Participant GMS
            </summary>
            <param name="mbr"></param>
        </member>
        <member name="M:GCT.Protocols.ParticipantGmsImpl.leave(GCT.Address)">
            <summary>
            Leaves the current group
            </summary>
            <param name="mbr">Local Address</param>
        </member>
        <member name="M:GCT.Protocols.ParticipantGmsImpl.handleJoinResponse(GCT.Protocols.JoinRsp)">
            <summary>
            Not implemented by Participant GMS
            </summary>
            <param name="join_rsp"></param>
        </member>
        <member name="M:GCT.Protocols.ParticipantGmsImpl.handleLeaveResponse">
            <summary>
            Response received to leave request
            </summary>
        </member>
        <member name="M:GCT.Protocols.ParticipantGmsImpl.suspect(GCT.Address)">
            <summary>
            Stores the member as suspected. See handleSuspect()
            </summary>
            <param name="mbr">Suspected member</param>
        </member>
        <member name="M:GCT.Protocols.ParticipantGmsImpl.unsuspect(GCT.Address)">
            <summary>
            Removes previously suspected member from list of currently suspected members
            </summary>
            <param name="mbr">Previously suspected member</param>
        </member>
        <member name="M:GCT.Protocols.ParticipantGmsImpl.handleJoin(GCT.Address)">
            <summary>
            Not implemented by Participant GMS
            </summary>
            <param name="mbr"></param>
            <returns></returns>
        </member>
        <member name="M:GCT.Protocols.ParticipantGmsImpl.handleLeave(GCT.Address,System.Boolean)">
            <summary>
            Not implemented by Participant GMS
            </summary>
            <param name="mbr"></param>
            <param name="suspected"></param>
        </member>
        <member name="M:GCT.Protocols.ParticipantGmsImpl.handleViewChange(GCT.View,GCT.Digest)">
            <remarks>
            If we are leaving, we have to wait for the view change (last msg in the current view) that
            excludes us before we can leave.
            </remarks>
            <summary>
            Installs a new view
            </summary>
            <param name="new_view">New View to install</param>
            <param name="digest">Digest associated with the view</param>
        </member>
        <member name="M:GCT.Protocols.ParticipantGmsImpl.handleSuspect(GCT.Address)">
            <summary>
            Stores the suspect member. If the member is the coordinator and we
            would be the next coordinator then become the coordinator 
            </summary>
            <param name="mbr">Suspected member</param>
        </member>
        <member name="M:GCT.Protocols.ParticipantGmsImpl.wouldIBeCoordinator">
            <remarks>
            Determines whether this member is the new coordinator given a list of suspected members.  This is
            computed as follows: the list of currently suspected members (suspected_mbrs) is removed from the current
            membership. If the first member of the resulting list is equals to the local_addr, then it is true,
            otherwise false. Example: own address is B, current membership is {A, B, C, D}, suspected members are 
            {A,D}. The resulting list is {B, C}. The first member of {B, C} is B, which is equal to the
            local_addr. Therefore, true is returned.
            </remarks>
            <summary>
            Returns true if this process should become the coordinator
            </summary>
            <returns>True if this process should become the coordinator</returns>
        </member>
        <member name="M:GCT.Protocols.ParticipantGmsImpl.sendLeaveMessage(GCT.Address,GCT.Address)">
            <summary>
            Sends a leave request to the coordinator
            </summary>
            <param name="coord">Address of the coordinator</param>
            <param name="mbr">Local Address</param>
        </member>
        <member name="T:GCT.Protocols.PING">
            <summary>
             Protocol: PING gets the initial members in the group
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.PING.members">
            <summary>Current members in the group</summary>
        </member>
        <member name="F:GCT.Protocols.PING.initial_members">
            <summary>List of responses to initial members request</summary>
        </member>
        <member name="F:GCT.Protocols.PING.local_addr">
            <summary>Local Address</summary>
        </member>
        <member name="F:GCT.Protocols.PING.group_addr">
            <summary>Group Multicast Address</summary>
        </member>
        <member name="F:GCT.Protocols.PING.timeout">
            <summary>Time interval to wait for responses</summary>
        </member>
        <member name="F:GCT.Protocols.PING.num_initial_members">
            <summary>Number of responses required to override timeout</summary>
        </member>
        <member name="F:GCT.Protocols.PING.is_server">
            <summary>If set channel is a member of the group</summary>
        </member>
        <member name="M:GCT.Protocols.PING.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GCT.Protocols.PING.providedUpServices">
            <summary>
            Provided services for layers below NAKACK
            </summary>
            <returns>List of provided service</returns>
        </member>
        <member name="M:GCT.Protocols.PING.setProperties(System.Data.PropertyCollection)">
            <summary>
            Sets the properties specified in the configuration string
            </summary>
            <param name="props">Properties to set</param>
            <returns>False if properties were specified that are not know, otherwise true</returns>
        </member>
        <member name="M:GCT.Protocols.PING.up(GCT.Event)">
            <summary>
            Processes <c>Events</c> travelling up the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.PING.down(GCT.Event)">
            <summary>
            Processes <c>Events</c> traveling down the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.PING.stop">
            <summary>
            Stops responding to requests 
            </summary>
        </member>
        <member name="M:GCT.Protocols.PING.initialMembersString">
            <summary>
            Returns string representation of initial members
            </summary>
            <returns>String representation of initial members</returns>
        </member>
        <member name="T:GCT.Protocols.PINGHeader">
            <summary>
            PING Header.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.PINGHeader.GET_MBRS_REQ">
            <summary>Header Type: Get members request</summary>
        </member>
        <member name="F:GCT.Protocols.PINGHeader.GET_MBRS_RSP">
            <summary>Header Type: Get members response</summary>
        </member>
        <member name="F:GCT.Protocols.PINGHeader.type">
            <summary>Header Type</summary>
        </member>
        <member name="F:GCT.Protocols.PINGHeader.arg">
            <summary>Response to request. Contains local and coordinator address</summary>
        </member>
        <member name="M:GCT.Protocols.PINGHeader.#ctor(System.Int32,GCT.Protocols.PingRsp)">
            <summary>
            Constructor
            </summary>
            <param name="type">Type of Header</param>
            <param name="arg">Response if applicable</param>
        </member>
        <member name="M:GCT.Protocols.PINGHeader.ToString">
            <summary>
            String representation of the Header
            </summary>
            <returns>String representation of the Header</returns>
        </member>
        <member name="M:GCT.Protocols.PINGHeader.type2Str(System.Int32)">
            <summary>
            Converts a type into a string represention
            </summary>
            <param name="t">The header type required</param>
            <returns>A type into a string represention</returns>
        </member>
        <member name="M:GCT.Protocols.PINGHeader.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialises the information
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="context">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="M:GCT.Protocols.PINGHeader.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor: Deserialises the information and recreates the instance.
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="ctxt">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="T:GCT.Protocols.PingRsp">
            <summary>
            Response object to request from PING
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.PingRsp.own_addr">
            <summary>Local Address</summary>
        </member>
        <member name="F:GCT.Protocols.PingRsp.coord_addr">
            <summary>Coordinator Address</summary>
        </member>
        <member name="M:GCT.Protocols.PingRsp.#ctor(GCT.Address,GCT.Address)">
            <summary>
            Constructor
            </summary>
            <param name="own_addr">Local Address</param>
            <param name="coord_addr">Coordinator Address</param>
        </member>
        <member name="M:GCT.Protocols.PingRsp.isCoord">
            <summary>
            Checks if the response is from the coordinator
            </summary>
            <returns>True if the response is from the coordinator</returns>
        </member>
        <member name="M:GCT.Protocols.PingRsp.toString">
            <summary>
            Returns a string representation of the current object
            </summary>
            <returns>A string representation of the current object</returns>
        </member>
        <member name="M:GCT.Protocols.PingRsp.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialises the information
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="context">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="M:GCT.Protocols.PingRsp.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor: Deserialises the information and recreates the instance.
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="ctxt">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="P:GCT.Protocols.PingRsp.OwnAddress">
            <summary>
            Gets the Local Address
            </summary>
        </member>
        <member name="P:GCT.Protocols.PingRsp.CoordAddress">
            <summary>
            Gets the Coordinator Address
            </summary>
        </member>
        <member name="T:GCT.Util.Promise">
            <remarks>
            The caller may choose to check
            for the result at a later time, or immediately and it may block or not. Both the caller and responder have to
            know the promise.
            </remarks>
            <summary>
            Allows a thread to submit an asynchronous request and to wait for the result.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Util.Promise.result">
            <summary>The result of the request</summary>
        </member>
        <member name="F:GCT.Util.Promise.mutex">
            <summary>Used to wait on the result</summary>
        </member>
        <member name="M:GCT.Util.Promise.getResult(System.Int64)">
            <summary>
            If result was already submitted, returns it immediately, else blocks until
            results becomes available. 
            </summary>
            <param name="timeout">Maximum time to wait for result.</param>
            <returns>Promise result</returns>
        </member>
        <member name="M:GCT.Util.Promise.checkForResult">
            <summary>
            Checks whether result is available. Does not block.
            </summary>
            <returns>Result if available</returns>
        </member>
        <member name="M:GCT.Util.Promise.setResult(System.Object)">
            <summary>
            Sets the result and notifies any threads waiting for it
            </summary>
            <param name="obj">Result of request</param>
        </member>
        <member name="M:GCT.Util.Promise.reset">
            <summary>
            Clears the result and causes all waiting threads to return
            </summary>
        </member>
        <member name="M:GCT.Util.Promise.toString">
            <summary>
            String representation of the result
            </summary>
            <returns>String representation of the result</returns>
        </member>
        <member name="T:GCT.Stack.ProtocolSinkStack">
            <remarks>
            The ProtocolStack manages a number of protocols layered above each other. 
            It creates all protocol classes, initializes them and, when ready, starts 
            all of them, beginning with the bottom most protocol. It also dispatches 
            messages received from the stack to registered objects (e.g. channel, GMP) 
            and sends messages sent by those objects down the stack.
            <p>
            The ProtocolStack is also the connecting class with the client and server Remoting 
            infrastructures. Remoting request messages are passed from the infrastructure and
            responses are passed back.
            </p>
            </remarks>
            <summary>
            Representation of stack of Protocols
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.top_prot">
            <summary>Top most Protocol in the stack</summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.bottom_prot">
            <summary>Bottom most Protocol in the stack</summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.conf">
            <summary>Helper class for creating and configurating Protocol layers</summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.setup_string">
            <summary>Initial stack configuration string</summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.channel">
            <summary>Channel associated with the stack</summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.local_addr">
            <summary>Local Address</summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.stopped">
            <summary>Determine whether the Stack is stopped</summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.timer">
            <summary>Scheduler of tasks</summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.objectURI">
            <summary>Object URI</summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.channelURI">
            <summary>Current Channel URI</summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.remotingTimeout">
            <summary>Time to wait for a response to a Remoting request</summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.remotingMutex">
            <summary>Used to sync requests and responses</summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.remotingResponses">
            <summary>List of Reomting responses</summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.members">
            <summary>Members in current group</summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.currentMethodCall">
            <summary>Stores the current Remoting request in transmission</summary>
        </member>
        <member name="F:GCT.Stack.ProtocolSinkStack.responseChooser">
            <summary>Chooses which response to deliver to the Remoting infrastructure</summary>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.#ctor(GCT.GroupChannel,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="chan">Channel associated with the stack</param>
            <param name="setup">Initial configuration string</param>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.setup">
            <remarks>
            The Up and Down handlers will be started.
            </remarks>
            <summary>
            Configures and initilises stack.
            </summary>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.down(GCT.Event)">
            <summary>
            Passes Events down the stack
            </summary>
            <param name="evt">Event to be passed down</param>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.startUpHandler">
            <summary>
            Overrides base class stopping superfluous threads
            </summary>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.startDownHandler">
            <summary>
            Overrides base class stopping superfluous threads
            </summary>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.start">
            <summary>
            Start all layers. 
            </summary>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.getProtocols">
            <summary>
            Returns a list of all the Protocols in the stack
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.stop">
            <summary>
            Stop all layers.
            </summary>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.destroy">
            <summary>
            Destroys message queues and threads
            </summary>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.up(GCT.Event)">
            <summary>
            Receives events from the top of the stack
            </summary>
            <param name="evt">Event received</param>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.determineResponse">
            <summary>
            Determines the Remoting response to send to the infrastructure.
            </summary>
            <returns>The IMessage response</returns>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.handleRemotingRequest(GCT.Stack.StackHeader)">
            <summary>
            Sends request into infrastructure, then passes back result.
            </summary>
            <param name="hdr">Header contain request.</param>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.handleRemotingResponse(GCT.Stack.StackHeader)">
            <summary>
            Stores all Remoting responses.
            </summary>
            <param name="hdr">Header contain response.</param>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.ProcessMessage(System.Runtime.Remoting.Channels.IServerChannelSinkStack,System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Channels.ITransportHeaders,System.IO.Stream,System.Runtime.Remoting.Messaging.IMessage@,System.Runtime.Remoting.Channels.ITransportHeaders@,System.IO.Stream@)">
            <remarks>
            Acts as though Remoting request has travalled up the server
            side Remoting channel.
            </remarks>
            <summary>
            Retrieves response to Remoting request.
            </summary>
            <param name="sinkStack">Default ServerChannelSinkStack</param>
            <param name="requestMsg">The request message</param>
            <param name="requestHeaders">No used.</param>
            <param name="requestStream">No used.</param>
            <param name="responseMsg">The response message to return</param>
            <param name="responseHeaders">No used.</param>
            <param name="responseStream">No used.</param>
            <returns></returns>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.AsyncProcessResponse(System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack,System.Object,System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Channels.ITransportHeaders,System.IO.Stream)">
            <summary>
            Not Supported by this channel.
            </summary>
            <param name="sinkStack"></param>
            <param name="state"></param>
            <param name="msg"></param>
            <param name="headers"></param>
            <param name="stream"></param>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.GetResponseStream(System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack,System.Object,System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Channels.ITransportHeaders)">
            <summary>
            This should never get called since we're behave as the last in the chain.
            </summary>
            <param name="sinkStack"></param>
            <param name="state"></param>
            <param name="msg"></param>
            <param name="headers"></param>
            <returns></returns>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)">
            <summary>
            Not Supported by this channel.
            </summary>
            <param name="msg"></param>
            <param name="replySink"></param>
            <returns></returns>
        </member>
        <member name="M:GCT.Stack.ProtocolSinkStack.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)">
            <remarks>
            The Remoting call is packaged as a message and sent to all group members.
            The response will be choosen using a chooser if present otherwise the 
            response with the most 'votes' will be chosen.
            </remarks>
            <summary>
            Processes the Remoting call.
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="P:GCT.Stack.ProtocolSinkStack.ResponseChooser">
            <summary>
            Gets or sets the RemotingChooser
            </summary>
        </member>
        <member name="P:GCT.Stack.ProtocolSinkStack.ObjectURI">
            <summary>
            Gets and sets the ObjectURI
            </summary>
        </member>
        <member name="P:GCT.Stack.ProtocolSinkStack.ChannelURI">
            <summary>
            Gets and sets the ChannelURI
            </summary>
        </member>
        <member name="P:GCT.Stack.ProtocolSinkStack.NextChannelSink">
            <summary>
            Should always be null.
            </summary>
        </member>
        <member name="P:GCT.Stack.ProtocolSinkStack.Properties">
            <summary>
            Should always be null.
            </summary>
        </member>
        <member name="P:GCT.Stack.ProtocolSinkStack.NextSink">
            <summary>
            There will be no other message sinks in the chain
            </summary>
        </member>
        <member name="T:GCT.Blocks.PullHeader">
            <summary>
            PullPushAdapter Header
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Blocks.PullHeader.identifier">
            <summary>
            Identifies which listener the message should be received by
            </summary>
        </member>
        <member name="M:GCT.Blocks.PullHeader.#ctor(System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="identifier">Identifies which listener the message should be received by</param>
        </member>
        <member name="M:GCT.Blocks.PullHeader.getIdentifier">
            <summary>
            Returns the identifier object 
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.Blocks.PullHeader.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialises the information
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="context">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="M:GCT.Blocks.PullHeader.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor: Deserialises the information and recreates the instance.
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="ctxt">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="T:GCT.Blocks.PullPushAdapter">
            <remarks>
            Typically used in the client role (receive()). As this class does not implement interface 
            <code>Transport</code>, but <b>uses</b> it for receiving messages, an underlying object
            has to be used to send messages (e.g. the channel on which an object of this class relies).
            <p>
            Multiple MembershipListeners can register with the PullPushAdapter; when a view is received, they
            will all be notified. There is one main message listener which sends and receives message. In addition,
            MessageListeners can register with a certain tag (identifier), and then send messages tagged with this
            identifier. When a message with such an identifier is received, the corresponding MessageListener will be
            looked up and the message dispatched to it. If no tag is found (default), the main MessageListener will
            receive the message.
            </p>
            </remarks>
            <summary>
            Allows a client of <em>Channel</em> to be notified when messages have been received
            instead of having to actively poll the channel for new messages.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Blocks.PullPushAdapter.PULL_HEADER">
            <summary>Used to identify messages sent by the adapter</summary>
        </member>
        <member name="F:GCT.Blocks.PullPushAdapter.transport">
            <summary>Transport (Channel) used to receive/send messages</summary>
        </member>
        <member name="F:GCT.Blocks.PullPushAdapter.listener">
            <summary>Singular/Default message listener</summary>
        </member>
        <member name="F:GCT.Blocks.PullPushAdapter.membership_listeners">
            <summary>All membership listeners</summary>
        </member>
        <member name="F:GCT.Blocks.PullPushAdapter.receiver_thread">
            <summary>Continually receives messages from the channel</summary>
        </member>
        <member name="F:GCT.Blocks.PullPushAdapter.listeners">
            <summary>Collection of listeners</summary>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.#ctor(GCT.Transport)">
            <summary>
            Constructor
            </summary>
            <param name="transport">Transport to send and receive messages from.</param>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.#ctor(GCT.Transport,GCT.MessageListener)">
            <summary>
            Constructor
            </summary>
            <param name="transport">Transport to send and receive messages from.</param>
            <param name="l">Default message listener</param>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.#ctor(GCT.Transport,GCT.MembershipListener)">
            <summary>
            Constructor
            </summary>
            <param name="transport">Transport to send and receive messages from.</param>
            <param name="ml">Membership listener</param>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.#ctor(GCT.Transport,GCT.MessageListener,GCT.MembershipListener)">
            <summary>
            Constructor
            </summary>
            <param name="transport">Transport to send and receive messages from.</param>
            <param name="l">Default message listener</param>
            <param name="ml">Membership listener</param>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.getTransport">
            <summary>
            Returns the Transport for sending/receiveing messages
            </summary>
            <returns>The Transport for sending/receiveing messages</returns>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.start">
            <summary>
            Starts listening to the transport
            </summary>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.stop">
            <summary>
            Stops listening to the transport
            </summary>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.send(System.Object,GCT.Message)">
            <summary>
            Sends a message.
            </summary>
            <param name="identifier">Listener object message will be returned to. If null then the default listener will be used</param>
            <param name="msg">Message to be sent</param>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.send(GCT.Message)">
            <summary>
            Sends a message.
            </summary>
            <param name="msg">Message to be sent.</param>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.setListener(GCT.MessageListener)">
            <summary>
            Sets the default MessageListener
            </summary>
            <param name="l">The Default message listener</param>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.registerListener(System.Object,GCT.MessageListener)">
            <summary>
            Registers a MessageListener with the adapter
            </summary>
            <param name="identifier">Identifing object of the listener</param>
            <param name="l">The MessageListener</param>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.addMembershipListener(GCT.MembershipListener)">
            <summary>
            Adds a MembershipListener.
            </summary>
            <param name="l">The MembershipListener</param>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.run">
            <summary>
            Receiver Thread : Removes Events (messages) from the channel
            </summary>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.handleMessage(GCT.Message)">
            <remarks>
            Check whether the message has an identifier. If yes, lookup the MessageListener associated with the
            given identifier in the hashtable and dispatch to it. Otherwise just use the main (default) message
            listener
            </remarks>
            <summary>
            Called once a message is received from the Transport.
            </summary>
            <param name="msg">Message received from the Transport</param>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.notifyViewChange(GCT.View)">
            <summary>
            Called once a View is received from the Transport.
            </summary>
            <param name="v">View received from the Transport</param>
        </member>
        <member name="M:GCT.Blocks.PullPushAdapter.notifySuspect(GCT.Address)">
            <summary>
            Called once a suspected member is received from the Transport.
            </summary>
            <param name="suspected_mbr">The suspected member received from the Transport</param>
        </member>
        <member name="T:GCT.Util.Range">
            <summary>
            Represents a range of messages that need retransmission. Contains the first and last seqeunce numbers.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Util.Range.low">
            <summary>The first message to be retransmitted</summary>
        </member>
        <member name="F:GCT.Util.Range.high">
            <summary>The last message to be retransmitted</summary>
        </member>
        <member name="M:GCT.Util.Range.#ctor(System.Int64,System.Int64)">
            <summary>
            Constructor
            </summary>
            <param name="low">The first message to be retransmitted</param>
            <param name="high">The last message to be retransmitted</param>
        </member>
        <member name="M:GCT.Util.Range.ToString">
            <summary>
            Returns a string representation of the Range.
            </summary>
            <returns>A string representation of the Range.</returns>
        </member>
        <member name="T:GCT.Remoting.RemotingRespChooser">
            <summary>
            Allows a selection from the Remoting responses.
            <p><b>Author:</b> Chris Koiak</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="M:GCT.Remoting.RemotingRespChooser.choice(System.Collections.ArrayList)">
            <summary>
            Called from the ProtocolSinkStack once a collection of Remoting response are recevied.
            </summary>
        </member>
        <member name="T:GCT.Util.IntException">
            <summary>
            Interrupted exception
            <p><b>Author:</b> Chris Koiak, Bela Ban, John Giorgiadis</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="M:GCT.Util.IntException.#ctor">
            <summary>Constructor</summary>
        </member>
        <member name="M:GCT.Util.IntException.#ctor(System.String)">
            <summary>Constructor</summary>
        </member>
        <member name="T:GCT.Util.BlockException">
            <summary>
            Exception thrown when a lock request would block the caller
            <p><b>Author:</b> Chris Koiak, Bela Ban, John Giorgiadis</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="M:GCT.Util.BlockException.#ctor">
            <summary>Constructor</summary>
        </member>
        <member name="M:GCT.Util.BlockException.#ctor(System.String)">
            <summary>Constructor</summary>
        </member>
        <member name="T:GCT.Util.RWLock">
            <summary>
            Lock allowing multiple reads or a single write. Waiting writes have 
            priority over new reads. 
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Util.RWLock._reads">
            <summary>Number of active read locks</summary>
        </member>
        <member name="F:GCT.Util.RWLock._waitWrites">
            <summary>Number of pending write lock requests</summary>
        </member>
        <member name="F:GCT.Util.RWLock._write">
            <summary>Whether the write lock is held</summary>
        </member>
        <member name="M:GCT.Util.RWLock.#ctor">
            <summary>
            Constructor: No lock exist at initialisation
            </summary>
        </member>
        <member name="M:GCT.Util.RWLock.readLock">
            <summary>
            Obtain a read lock 
            </summary>
        </member>
        <member name="M:GCT.Util.RWLock.readUnlock">
            <summary>
            Revoke the read lock
            </summary>
        </member>
        <member name="M:GCT.Util.RWLock.readLockNoBlock">
            <summary>
            Obtain the read lock immediately
            </summary>
        </member>
        <member name="M:GCT.Util.RWLock.writeLock">
            <summary>
            Obtain a write lock 
            </summary>
        </member>
        <member name="M:GCT.Util.RWLock.writeUnlock">
            <summary>
            Revoke the write lock 
            </summary>
        </member>
        <member name="M:GCT.Util.RWLock.writeLockNoBlock">
            <summary>
            Obtain the write lock immediatelly
            </summary>
        </member>
        <member name="T:GCT.Protocols.STABLE">
            <remarks>
            Computes the broadcast messages that are stable, i.e. have been received by all members. Sends
            STABLE events up the stack when this is the case. This allows NAKACK to garbage collect messages that
            have been seen by all members.
            <p>
            Works as follows: periodically we mcast our highest seqnos (seen for each member) to the group.
            A stability vector, which maintains the highest seqno for each member and initially contains no data,
            is updated when such a message is received. The entry for a member P is computed set to 
            min(entry[P], digest[P]). When messages from all members have been received, a stability
            message is mcast, which causes all members to send a STABLE event up the stack (triggering garbage collection
            in the NAKACK layer).</p>
            <p>
            The stable task now terminates after max_num_gossips if no messages or view changes have been sent or received
            in the meantime. It will resume when messages are received. This effectively suspends sending superfluous
            STABLE messages in the face of no activity.</p>
            </remarks>
            <summary>
            Protocol : STABLE computes the broadcast messages that are stable
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.local_addr">
            <summary>Local Address</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.mbrs">
            <summary>Current Members in the group</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.digest">
            <summary>Keeps track of the highest seqnos from all members</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.digest_promise">
            <summary>Synchronises the reception of the digest</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.heard_from">
            <summary>Keeps track of the members that have already responded</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.digest_timeout">
            <summary>Time to wait until digest is received </summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.desired_avg_gossip">
            <summary>Receive a STABLE gossip every x seconds</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.stability_delay">
            <summary>Delay before we send STABILITY msg</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.stability_task">
            <summary>Scheduled task the sends stability message</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.stability_mutex">
            <summary>Synchronizes on stability_task</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.stable_task">
            <summary>Multicasts periodic STABLE message</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.timer">
            <summary>To send periodic STABLE/STABILITY msgs</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.max_gossip_runs">
            <summary>maximum number of times the StableTask runs before terminating</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.num_gossip_runs">
            <summary>Decrementing gossips still to be performed</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.random">
            <summary>Ranom number generator</summary>
        </member>
        <member name="M:GCT.Protocols.STABLE.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:GCT.Protocols.STABLE.getName">
            <summary>
            Returns unique protocol name
            </summary>
            <returns>Unique protocol name</returns>
        </member>
        <member name="M:GCT.Protocols.STABLE.requiredUpServices">
            <summary>
            List of Events that need to be handled by layers above.
            </summary>
            <returns>List of Events that need to be handled by layers above.</returns>
        </member>
        <member name="M:GCT.Protocols.STABLE.setProperties(System.Data.PropertyCollection)">
            <summary>
            Sets the properties specified in the configuration string
            </summary>
            <param name="props">Properties to set</param>
            <returns>False if properties were specified that are not know, otherwise true</returns>
        </member>
        <member name="M:GCT.Protocols.STABLE.start">
            <summary>
            Sets the Scheduler to the Scheduler present in the ProtocolSinkStack
            </summary>
        </member>
        <member name="M:GCT.Protocols.STABLE.stop">
            <summary>
            Stops any stability gossiping
            </summary>
        </member>
        <member name="M:GCT.Protocols.STABLE.up(GCT.Event)">
            <summary>
            Processes <c>Events</c> travelling up the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.STABLE.down(GCT.Event)">
            <summary>
            Processes <c>Events</c> traveling down the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.STABLE.initialize">
            <summary>
            Initialises (resets) the members heard from and the stable digest.
            </summary>
        </member>
        <member name="M:GCT.Protocols.STABLE.startStableTask">
            <summary>
            Starts the checking for stability
            </summary>
        </member>
        <member name="M:GCT.Protocols.STABLE.stopStableTask">
            <summary>
            Stops the checking for stability
            </summary>
        </member>
        <member name="M:GCT.Protocols.STABLE.handleStableGossip(GCT.Address,GCT.Digest)">
            <remarks>
            Digest d contains (a) the highest seqnos <em>deliverable</em> for each sender and (b) the highest seqnos
            <em>seen</em> for each member. (Difference: with 1,2,4,5, the highest seqno seen is 5, whereas the highest
            seqno deliverable is 2). The minimum of all highest seqnos deliverable will be taken to send a stability
            message, which results in garbage collection of messages lower than the ones in the stability vector. The
            maximum of all seqnos will be taken to trigger possible retransmission of last missing seqno.
            </remarks>
            <summary>
            Called when a stability gossip is received.
            </summary>
            <param name="sender">Sender of the gossip</param>
            <param name="d">The digest on the senders channel</param>
        </member>
        <member name="M:GCT.Protocols.STABLE.sendStabilityMessage(GCT.Digest)">
            <remarks>
            The reason for waiting a random amount of time is that, in the worst case, all members receive a
            STABLE_GOSSIP message from the last outstanding member at the same time and would therefore mcast the
            STABILITY message at the same time too. To avoid this, each member waits random N msecs. If, before N
            elapses, some other member sent the STABILITY message, we just cancel our own message. If, during
            waiting for N msecs to send STABILITY message S1, another STABILITY message S2 is to be sent, we just 
            discard S2.
            </remarks>
            <summary>
            Schedules a stability message to be mcast after a random number of milliseconds.
            </summary>
            <param name="tmp">Stable Digest</param>
        </member>
        <member name="M:GCT.Protocols.STABLE.handleStabilityMessage(GCT.Digest)">
            <summary>
            Stops any awaiting stability multicasts, passes STABLE Event up the stack.
            </summary>
            <param name="d">Stable Digest</param>
        </member>
        <member name="M:GCT.Protocols.STABLE.printStabilityDigest(GCT.Digest)">
            <summary>
            Returns a string representation of the stable digest
            </summary>
            <param name="d">Stable Digest</param>
            <returns>A string representation of the stable digest</returns>
        </member>
        <member name="T:GCT.Protocols.STABLE.StableTask">
            <remarks>
            Interval between sends varies. Terminates after num_gossip_runs is 0.
            However, UP or DOWN messages will reset num_gossip_runs to max_gossip_runs. This has the effect that the
            stable_send task terminates only after a period of time within which no messages were either sent 
            or received
            </remarks>
            <summary>
            Multicasts periodic STABLE message.
            </summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.StableTask.stopped">
            <summary>Determines if task is active</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.StableTask.stable">
            <summary>STABLE protocol associated with the Task</summary>
        </member>
        <member name="M:GCT.Protocols.STABLE.StableTask.#ctor(GCT.Protocols.STABLE)">
            <summary>
            Constructor
            </summary>
            <param name="stable">STABLE protocol associated with the Task</param>
        </member>
        <member name="M:GCT.Protocols.STABLE.StableTask.reset">
            <summary>
            Sets the task active
            </summary>
        </member>
        <member name="M:GCT.Protocols.STABLE.StableTask.stop">
            <summary>
            Sets the task to inactive
            </summary>
        </member>
        <member name="M:GCT.Protocols.STABLE.StableTask.getName">
            <summary>
            Returns the name of the Task
            </summary>
            <returns>The name of the Task</returns>
        </member>
        <member name="M:GCT.Protocols.STABLE.StableTask.cancelled">
            <summary>
            Checks if the Task is cancelled (inactive)
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.Protocols.STABLE.StableTask.nextInterval">
            <summary>
            Gets the next interval til gossip is received
            </summary>
            <returns>The next interval til gossip is received</returns>
        </member>
        <member name="M:GCT.Protocols.STABLE.StableTask.run">
            <summary>
            Sends stable gossip messages until maximum is reached
            </summary>
        </member>
        <member name="M:GCT.Protocols.STABLE.StableTask.computeSleepTime">
            <summary>
            Calculates the next interval time
            </summary>
            <returns>The next interval time</returns>
        </member>
        <member name="M:GCT.Protocols.STABLE.StableTask.sendStableMessage">
            <remarks>
            Message contains highest seqnos of all members
            seen by this member. Highest seqnos are retrieved from the NAKACK layer above.
            </remarks>
            <summary>
            Multicasts a STABLE message to all group members.
            </summary>
        </member>
        <member name="M:GCT.Protocols.STABLE.StableTask.getDigest">
            <summary>
            Gets the current digest in the channel
            </summary>
            <returns>The current digest in the channel</returns>
        </member>
        <member name="T:GCT.Protocols.STABLE.StabilitySendTask">
            <summary>
            Multicasts a STABILITY message.
            </summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.StabilitySendTask.d">
            <summary>Stable Digest</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.StabilitySendTask.stable_prot">
            <summary></summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.StabilitySendTask.stopped">
            <summary>STABLE protocol associated with the Task</summary>
        </member>
        <member name="F:GCT.Protocols.STABLE.StabilitySendTask.delay">
            <summary>Delay before sending message </summary>
        </member>
        <member name="M:GCT.Protocols.STABLE.StabilitySendTask.#ctor(GCT.Stack.Protocol,GCT.Digest,System.Int64)">
            <summary>
            Constructor
            </summary>
            <param name="stable_prot">STABLE protocol associated with the Task</param>
            <param name="d">Stable Digest</param>
            <param name="delay">Delay before sending message</param>
        </member>
        <member name="M:GCT.Protocols.STABLE.StabilitySendTask.getName">
            <summary>
            Return the name of the Task
            </summary>
            <returns>The name of the Task</returns>
        </member>
        <member name="M:GCT.Protocols.STABLE.StabilitySendTask.stop">
            <summary>
            Stops the Task
            </summary>
        </member>
        <member name="M:GCT.Protocols.STABLE.StabilitySendTask.cancelled">
            <summary>
            Checks if the Task is stopped
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.Protocols.STABLE.StabilitySendTask.nextInterval">
            <summary>
            Wait a random number of msecs (to give other a chance to send the STABILITY msg first)
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.Protocols.STABLE.StabilitySendTask.run">
            <summary>
            Sends the stability message to all members.
            </summary>
        </member>
        <member name="T:GCT.Protocols.StableHeader">
            <summary>
            STABLE Header.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.StableHeader.STABLE_GOSSIP">
            <summary>Header Type: Request for digest</summary>
        </member>
        <member name="F:GCT.Protocols.StableHeader.STABILITY">
            <summary>Header Type: Stable Digest</summary>
        </member>
        <member name="F:GCT.Protocols.StableHeader.type">
            <summary>Header Type</summary>s
        </member>
        <member name="F:GCT.Protocols.StableHeader.digest">
            <summary>Digest sent with both types of Header</summary>
        </member>
        <member name="M:GCT.Protocols.StableHeader.#ctor(System.Int32,GCT.Digest)">
            <summary>
            Constructor
            </summary>
            <param name="type">Header type</param>
            <param name="digest">Stable or unstable digest</param>
        </member>
        <member name="M:GCT.Protocols.StableHeader.type2String(System.Int32)">
            <summary>
            Converts a type into a string represention
            </summary>
            <param name="t">The header type required</param>
            <returns>A type into a string represention</returns>	
        </member>
        <member name="M:GCT.Protocols.StableHeader.toString">
            <summary>
            String representation of the Header
            </summary>
            <returns>String representation of the Header</returns>
        </member>
        <member name="M:GCT.Protocols.StableHeader.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialises the information
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="context">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="M:GCT.Protocols.StableHeader.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor: Deserialises the information and recreates the instance.
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="ctxt">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="T:GCT.Stack.StackHeader">
            <summary>
             ProtocolSinkStack Header
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Stack.StackHeader.REMOTE_REQ">
            <summary>Header Type: Remoting request</summary>
        </member>
        <member name="F:GCT.Stack.StackHeader.REMOTE_RSP">
            <summary>Header Type: Remoting response</summary>
        </member>
        <member name="F:GCT.Stack.StackHeader.type">
            <summary>Header Type</summary>
        </member>
        <member name="F:GCT.Stack.StackHeader.msg">
            <summary>Request or Response</summary>
        </member>
        <member name="F:GCT.Stack.StackHeader.source">
            <summary>Sender of request</summary>
        </member>
        <member name="F:GCT.Stack.StackHeader.objectUri">
            <summary>Needed for deserialisation</summary>
        </member>
        <member name="F:GCT.Stack.StackHeader.stream">
            <summary>Response message stream</summary>
        </member>
        <member name="M:GCT.Stack.StackHeader.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="type">Header type</param>
        </member>
        <member name="M:GCT.Stack.StackHeader.#ctor(System.Int32,System.Runtime.Remoting.Messaging.IMessage,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="type">Header type</param>
            <param name="msg">Remoting message</param>
            <param name="objectUri">Remote Object Uri</param>
        </member>
        <member name="M:GCT.Stack.StackHeader.type2String(System.Int32)">
            <summary>
            Converts a type into a string represention
            </summary>
            <param name="t">The header type required</param>
            <returns>A type into a string represention</returns>
        </member>
        <member name="M:GCT.Stack.StackHeader.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialises the information
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="context">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="M:GCT.Stack.StackHeader.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor: Deserialises the information and recreates the instance.
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="ctxt">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="M:GCT.Stack.StackHeader.deserializeResponse(System.Runtime.Remoting.Messaging.IMethodCallMessage)">
            <remarks>
            This is performed seperately as the initial message request is needed
            to deserialize the response properly.
            </remarks>
            <summary>
            Deserialises the request message.
            </summary>
            <param name="reqMsg"></param>
        </member>
        <member name="P:GCT.Stack.StackHeader.Message">
            <summary>
            Gets and sets the Remoting message
            </summary>
        </member>
        <member name="P:GCT.Stack.StackHeader.Type">
            <summary>
            Gets the header type
            </summary>
        </member>
        <member name="P:GCT.Stack.StackHeader.Source">
            <summary>
            Gets the sender of the message
            </summary>
        </member>
        <member name="T:GCT.Stack.StackHeader.UriHeaderHandler">
            <summary>
            Used to pass uri into binary serializer, so that the message
            gets the object uri.
            </summary>
        </member>
        <member name="T:GCT.Remoting.TimeChooser">
            <summary>
            Selects the median DateTime from the Remoting responses.
            <p><b>Author:</b> Chris Koiak</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="M:GCT.Remoting.TimeChooser.choice(System.Collections.ArrayList)">
            <summary>
            Called to choose the median of the responses
            </summary>
            <param name="responses">List of Remoting Responses</param>
            <returns>The median of the DateTime responses</returns>
        </member>
        <member name="T:GCT.Trace">
            <summary>
            Debug tool, used to output information and errors to a file/screen
            <p><b>Author:</b> Chris Koiak</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Trace.trace">
            <summary>Determines if tracing is enabled</summary>
        </member>
        <member name="M:GCT.Trace.info(System.String,System.String)">
            <summary>
            Information Trace
            </summary>
            <param name="module">Module responsible for the information</param>
            <param name="message">The message to be displayed</param>
        </member>
        <member name="M:GCT.Trace.warn(System.String,System.String)">
            <summary>
            Warning Trace
            </summary>
            <param name="module">Module responsible for the warning</param>
            <param name="message">The message to be displayed</param>
        </member>
        <member name="M:GCT.Trace.error(System.String,System.String)">
            <summary>
            Error Trace
            </summary>
            <param name="module">Module responsible for the error</param>
            <param name="message">The message to be displayed</param>
        </member>
        <member name="M:GCT.Trace.writeToDebug(System.String,System.String,System.String)">
            <summary>
            Writes the trace to the Debug
            </summary>
            <param name="type">Type of trace</param>
            <param name="module">Module responsible for the error</param>
            <param name="message">The message to be displayed</param>
        </member>
        <member name="T:GCT.Protocols.TransportableVectorTimeStamp">
            <summary>
            Representation of current number of messages sent by each group member. This is the 
            lightweight version of VectorTimeStamp as it doesnt store the actual member addresses.
            </summary>
        </member>
        <member name="F:GCT.Protocols.TransportableVectorTimeStamp.messagesSent">
            <summary>Array of the current max number of messages send by each member.</summary>
        </member>
        <member name="F:GCT.Protocols.TransportableVectorTimeStamp.senderPosition">
            <summary>The position in the messagesSent array of the message sender</summary>
        </member>
        <member name="F:GCT.Protocols.TransportableVectorTimeStamp.associatedMessage">
            <summary>The associated message. Used to hold the message if the timestamp is not causally next</summary>
        </member>
        <member name="M:GCT.Protocols.TransportableVectorTimeStamp.#ctor(System.Int32[],System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="messagesSent">Array of the current max number of messages send by each member.</param>
            <param name="senderPosition">The position in the messagesSent array of the message sender</param>
        </member>
        <member name="M:GCT.Protocols.TransportableVectorTimeStamp.#ctor(System.Int32[],System.Int32,GCT.Message)">
            <summary>
            Constructor
            </summary>
            <param name="messagesSent">Array of the current max number of messages send by each member.</param>
            <param name="senderPosition">The position in the messagesSent array of the message sender</param>
            <param name="associatedMessage">The message associated with the vector time stamp</param>
        </member>
        <member name="M:GCT.Protocols.TransportableVectorTimeStamp.lessThanOrEquals(GCT.Protocols.TransportableVectorTimeStamp)">
            <summary>
            A vector time stamp, A, is less than or equal to another vector time stamp, B,
            if each element in A is less than or equal to the corresponding element in B.
            </summary>
            <param name="vStamp2">The vector time stamp to compare to</param>
            <returns>True if the specified arguement is greater than the object</returns>
        </member>
        <member name="M:GCT.Protocols.TransportableVectorTimeStamp.equals(GCT.Protocols.TransportableVectorTimeStamp)">
            <summary>
            A vector time stamp, A, is lequal to another vector time stamp, B,
            if each element in A is equal to the corresponding element in B.
            </summary>
            <param name="vStamp2"></param>
            <returns></returns>
        </member>
        <member name="P:GCT.Protocols.TransportableVectorTimeStamp.MessagesSent">
            <summary>
            Gets or Sets the vector time stamp
            </summary>
        </member>
        <member name="P:GCT.Protocols.TransportableVectorTimeStamp.SenderPosition">
            <summary>
            Gets or sets the senders position in the vector time stamp
            </summary>
        </member>
        <member name="P:GCT.Protocols.TransportableVectorTimeStamp.AssosicatedMessage">
            <summary>
            Gets or sets the time stamps associated message.
            </summary>
        </member>
        <member name="T:GCT.Protocols.UDP">
            <summary>
            Protocol: UDP sends and receives unicast and multicast messages.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.UDP.recvMcast">
            <summary>Receives incoming multicast messages</summary>
        </member>
        <member name="F:GCT.Protocols.UDP.recvUcast">
            <summary>Receives incoming unicast messages</summary>
        </member>
        <member name="F:GCT.Protocols.UDP.ucastRecvSocket">
            <summary>Socket for receiving unicast packets</summary>
        </member>
        <member name="F:GCT.Protocols.UDP.ucastSendSocket">
            <summary>Socket for sending unicast packets</summary>
        </member>
        <member name="F:GCT.Protocols.UDP.mcastSendSocket">
            <summary>Socket for sending multicast packets</summary>
        </member>
        <member name="F:GCT.Protocols.UDP.mcastRecvSocket">
            <summary>Socket for receiving multicast packets</summary>
        </member>
        <member name="F:GCT.Protocols.UDP.bind_addr">
            <summary>Local address unicast address</summary>
        </member>
        <member name="F:GCT.Protocols.UDP.udp_hdr">
            <summary>Header added to all outgoing messages</summary>
        </member>
        <member name="F:GCT.Protocols.UDP.group_addr">
            <summary>Group name/address to connect to</summary>
        </member>
        <member name="F:GCT.Protocols.UDP.mcast_addr">
            <summary>Multicast address</summary>
        </member>
        <member name="F:GCT.Protocols.UDP.ip_ttl">
            <summary>Time-To-Live of multicast messages</summary>
        </member>
        <member name="F:GCT.Protocols.UDP.members">
            <summary>Current members in the group</summary>
        </member>
        <member name="F:GCT.Protocols.UDP.mcast_send_buf_size">
            <summary>Size of multicast send buffer</summary>
        </member>
        <member name="F:GCT.Protocols.UDP.mcast_recv_buf_size">
            <summary>Size of multicast receive buffer</summary>
        </member>
        <member name="F:GCT.Protocols.UDP.ucast_send_buf_size">
            <summary>Size of unicast send buffer</summary>
        </member>
        <member name="F:GCT.Protocols.UDP.ucast_recv_buf_size">
            <summary>Size of unicast receive buffer</summary>
        </member>
        <member name="M:GCT.Protocols.UDP.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GCT.Protocols.UDP.setProperties(System.Data.PropertyCollection)">
            <summary>
            Sets the properties specified in the configuration string
            </summary>
            <param name="props">Properties to set</param>
            <returns>False if properties were specified that are not know, otherwise true</returns>
        </member>
        <member name="M:GCT.Protocols.UDP.up(GCT.Event)">
            <summary>
            Processes <c>Events</c> travelling up the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.UDP.down(GCT.Event)">
            <summary>
            Processes <c>Events</c> traveling down the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.UDP.start">
            <summary>
            Creates sockets, informs protocols of the local address 
            and starts listening for incoming messages.
            </summary>
        </member>
        <member name="M:GCT.Protocols.UDP.handleDownEvent(GCT.Event)">
            <summary>
            Handles any event that is not a Message
            </summary>
            <param name="evt">Event</param>
        </member>
        <member name="M:GCT.Protocols.UDP.stop">
            <summary>
            Closes all sockets and stops the Threads
            </summary>
        </member>
        <member name="M:GCT.Protocols.UDP.createSockets">
            <remarks>
            If the specified (or default) port is in use then try the next 10
            ports for access.
            </remarks>
            <summary>
            Creates four sockets; listening and sending on both multicast and unicast addresses
            </summary>
        </member>
        <member name="M:GCT.Protocols.UDP.closeSockets">
            <summary>
            Closes the four sockets.
            </summary>
        </member>
        <member name="M:GCT.Protocols.UDP.startThreads">
            <summary>
            Starts listening for incoming packets
            </summary>
        </member>
        <member name="M:GCT.Protocols.UDP.stopThreads">
            <summary>
            Stop listening for incoming packets
            </summary>
        </member>
        <member name="M:GCT.Protocols.UDP.receiveMCast">
            <summary>
            Running in a seperate thread, will recieve incoming mulitcasts
            </summary>
        </member>
        <member name="M:GCT.Protocols.UDP.receiveUCast">
            <summary>
            Running in a seperate thread, will recieve incoming unicasts
            </summary>
        </member>
        <member name="M:GCT.Protocols.UDP.handleIncomingUdpPacket(System.Byte[])">
            <summary>
            Process <i>any</i> incoming message once it is received.
            </summary>
            <param name="packet">Message Payload</param>
        </member>
        <member name="M:GCT.Protocols.UDP.sendUdpMessage(GCT.Message)">
            <summary>
            Sends a <c>Message</c> using UDP
            </summary>
            <param name="msg">Message to be sent</param>
        </member>
        <member name="M:GCT.Protocols.UDP.setSourceAddress(GCT.Message)">
            <summary>
            Sets the source address on a <c>Message</c> to the local Address
            </summary>
            <param name="msg">Message to be set</param>
        </member>
        <member name="T:GCT.Protocols.UDPHeader">
            <summary>
            UDP Header
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.UDPHeader.group_addr">
            <summary>Name of group message is intended for.</summary>
        </member>
        <member name="M:GCT.Protocols.UDPHeader.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="group_addr">Name of group message is intended for.</param>
        </member>
        <member name="M:GCT.Protocols.UDPHeader.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialises the information
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="context">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="M:GCT.Protocols.UDPHeader.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor: Deserialises the information and recreates the instance.
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="ctxt">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="P:GCT.Protocols.UDPHeader.GroupAddress">
            <summary>
            Gets Name/Address of the current group
            </summary>
        </member>
        <member name="T:GCT.Protocols.UNICAST">
            <remarks>
            Uses acknowledgement scheme similar to TCP to provide lossless transmission
            of unicast messages (for reliable multicast see NAKACK layer). When a message is sent to a peer for
            the first time, we add the pair (peer_addr, Entry) to the hashtable (peer address is the key). All
            messages sent to that peer will be added to hashtable.peer_addr.sent_msgs. When we receive a
            message from a peer for the first time, another entry will be created and added to the hashtable
            (unless already existing). Msgs will then be added to hashtable.peer_addr.received_msgs.
            <p> 
            This layer is used to reliably transmit point-to-point messages, that is, either messages sent to a
            single receiver (vs. messages multicast to a group) or for example replies to a multicast message. The 
            sender uses an <code>AckSenderWindow</code> which retransmits messages for which it hasn't received
            an ACK, the receiver uses <code>AckReceiverWindow</code> which keeps track of the lowest seqno
            received so far, and keeps messages in order.</p>
            <p>
            Messages in both AckSenderWindows and AckReceiverWindows will be removed. A message will be removed from
            AckSenderWindow when an ACK has been received for it and messages will be removed from AckReceiverWindow
            whenever a message is received: the new message is added and then we try to remove as many messages as
            possible (until we stop at a gap, or there are no more messages).</p>
            </remarks>
            <summary>
            Protocol: Reliable unicast layer.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.UNICAST.operational">
            <summary>Signifies the channel is active</summary>
        </member>
        <member name="F:GCT.Protocols.UNICAST.members">
            <summary>Current members in the group</summary>
        </member>
        <member name="F:GCT.Protocols.UNICAST.connections">
            <summary>Contains Entries for each member</summary>
        </member>
        <member name="F:GCT.Protocols.UNICAST.timeout">
            <summary>For AckSenderWindow: max time to wait for missing acks</summary>
        </member>
        <member name="F:GCT.Protocols.UNICAST.local_addr">
            <summary>Local Address</summary>
        </member>
        <member name="F:GCT.Protocols.UNICAST.timer">
            <summary>Scheduler used for retransmissions (AckSenderWindow)</summary>
        </member>
        <member name="F:GCT.Protocols.UNICAST.window_size">
            <summary>Sliding window: Max number of msgs in table (AckSenderWindow)</summary>
        </member>
        <member name="F:GCT.Protocols.UNICAST.min_threshold">
            <summary>Sliding window: Number under which table has to fall before we resume adding msgs (AckSenderWindow)</summary>
        </member>
        <member name="M:GCT.Protocols.UNICAST.#ctor">
            <summary>
            Protocol : STABLE computes the broadcast messages that are stable
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="M:GCT.Protocols.UNICAST.getName">
            <summary>
            Returns unique protocol name
            </summary>
            <returns>Unique protocol name</returns>
        </member>
        <member name="M:GCT.Protocols.UNICAST.setProperties(System.Data.PropertyCollection)">
            <summary>
            Sets the properties specified in the configuration string
            </summary>
            <param name="props">Properties to set</param>
            <returns>False if properties were specified that are not know, otherwise true</returns>
        </member>
        <member name="M:GCT.Protocols.UNICAST.start">
            <summary>
            Sets the Scheduler to the Scheduler present in the ProtocolSinkStack
            </summary>
        </member>
        <member name="M:GCT.Protocols.UNICAST.stop">
            <summary>
            Resets and removes all sender and receiver windows.
            </summary>
        </member>
        <member name="M:GCT.Protocols.UNICAST.up(GCT.Event)">
            <summary>
            Processes <c>Events</c> travelling up the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.UNICAST.down(GCT.Event)">
            <summary>
            Processes <c>Events</c> traveling down the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.UNICAST.removeAllConnections">
            <summary>
            Resets and removes all sender and receiver windows.
            </summary>
        </member>
        <member name="M:GCT.Protocols.UNICAST.getInitialSeqno">
            <summary>
            Returns random initial sequence number between 1 and 100
            </summary>
            <returns>Random initial sequence number between 1 and 100</returns>
        </member>
        <member name="M:GCT.Protocols.UNICAST.retransmit(System.Int64,GCT.Message)">
            <summary>
            Called by AckSenderWindow to resend messages for which no ACK has been received yet
            </summary>
            <param name="seqno">Sequence number of Message to retransmit</param>
            <param name="msg">Message to retransmit</param>
        </member>
        <member name="M:GCT.Protocols.UNICAST.handleDataReceived(System.Object,System.Int64,System.Boolean,GCT.Message)">
            <remarks>
            Check whether the hashtable contains an entry e for <code>sender</code> (create if not). If
            e.received_msgs is null and <code>first</code> is true: create a new AckReceiverWindow(seqno) and
            add message. Set e.received_msgs to the new window. Else just add the message. If first is false,
            but we don't yet have hashtable.received_msgs, then just discard the message. If first is true, but
            hashtable.received_msgs already exists, also discard the message (redundant message).
            </remarks>
            <summary>
            Processes a unicast Message once received
            </summary>
            <param name="sender">Sender of the Message</param>
            <param name="seqno">Sequence number of received Message</param>
            <param name="first">True if first message from sender</param>
            <param name="msg">Message received</param>
        </member>
        <member name="M:GCT.Protocols.UNICAST.handleAckReceived(System.Object,System.Int64)">
            <summary>
            Add the acknowledgement (ACK) to hashtable.sender.sent_msgs
            </summary>
            <param name="sender">Sender of the Message</param>
            <param name="seqno">Sequence number of received Message</param>
        </member>
        <member name="M:GCT.Protocols.UNICAST.sendAck(GCT.Address,System.Int64)">
            <summary>
            Sends an acknowledgement (ACK) to the sender of the message
            </summary>
            <param name="dst">Sender of the Message</param>
            <param name="seqno">Sequence number of received Message</param>
        </member>
        <member name="T:GCT.Protocols.UNICAST.Entry">
            <summary>
            An Entry is stored for every member that sends a message
            </summary>
        </member>
        <member name="F:GCT.Protocols.UNICAST.Entry.received_msgs">
            <summary>Stores all msgs received by a certain peer in seqno-order</summary>
        </member>
        <member name="F:GCT.Protocols.UNICAST.Entry.sent_msgs">
            <summary>Stores (and retransmits) msgs sent by us to a certain peer</summary>
        </member>
        <member name="F:GCT.Protocols.UNICAST.Entry.sent_msgs_seqno">
            <summary>Sequence numebr for msgs sent by this channel</summary>
        </member>
        <member name="F:GCT.Protocols.UNICAST.Entry.uni">
            <summary>UNICAST Protocol associated with the Entry</summary>
        </member>
        <member name="M:GCT.Protocols.UNICAST.Entry.#ctor(GCT.Protocols.UNICAST)">
            <summary>
            Constructor
            </summary>
            <param name="uni">UNICAST Protocol associated with the Entry</param>
        </member>
        <member name="M:GCT.Protocols.UNICAST.Entry.reset">
            <summary>
            Resets the AckReceiverWindow and the AckSenderWindow
            </summary>
        </member>
        <member name="M:GCT.Protocols.UNICAST.Entry.toString">
            <summary>
            Returns a string representation of the Entry
            </summary>
            <returns>A string representation of the Entry</returns>
        </member>
        <member name="T:GCT.Protocols.UnicastHeader">
            <summary>
            UNICAST Header
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.UnicastHeader.DATA">
            <summary>Header Type: Standard message</summary>
        </member>
        <member name="F:GCT.Protocols.UnicastHeader.DATA_ACK">
            <summary>Header Type: Message Acknowledgement</summary>
        </member>
        <member name="F:GCT.Protocols.UnicastHeader.type">
            <summary>Header Type</summary>
        </member>
        <member name="F:GCT.Protocols.UnicastHeader.seqno">
            <summary>Sequence number of the message</summary>
        </member>
        <member name="F:GCT.Protocols.UnicastHeader.first">
            <summary>Determines if the message is the first message</summary>
        </member>
        <member name="M:GCT.Protocols.UnicastHeader.#ctor(System.Int32,System.Int64)">
            <summary>
            Constructor
            </summary>
            <param name="type">Header Type</param>
            <param name="seqno">Sequence number of message</param>
        </member>
        <member name="M:GCT.Protocols.UnicastHeader.toString">
            <summary>
            String representation of the Header
            </summary>
            <returns>String representation of the Header</returns>
        </member>
        <member name="M:GCT.Protocols.UnicastHeader.type2Str(System.Int32)">
            <summary>
            Converts a type into a string represention
            </summary>
            <param name="t">The header type required</param>
            <returns>A type into a string represention</returns>
        </member>
        <member name="M:GCT.Protocols.UnicastHeader.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialises the information
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="context">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="M:GCT.Protocols.UnicastHeader.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor: Deserialises the information and recreates the instance.
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="ctxt">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="T:GCT.UpHandler">
            <summary>
            Allows messages to be received from the Channel, used to pass messages
            to a 'Building Block'
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="M:GCT.UpHandler.up(GCT.Event)">
            <summary>
            Receives an Event from the Channel
            </summary>
            <param name="evt">Event received</param>
        </member>
        <member name="T:GCT.Protocols.VectorTimeStamp">
            <summary>
            Vector Time Stamp for causal message ordering.
            </summary>
        </member>
        <member name="F:GCT.Protocols.VectorTimeStamp.members">
            <summary>Sorted list of members. Key=Address Value=Number Messages sent</summary>
        </member>
        <member name="F:GCT.Protocols.VectorTimeStamp.owner">
            <summary>Address of the owner of the timestamp</summary>
        </member>
        <member name="F:GCT.Protocols.VectorTimeStamp.ownerIndex">
            <summary>Index of the owner inside the members collection</summary>
        </member>
        <member name="M:GCT.Protocols.VectorTimeStamp.#ctor(GCT.Address)">
            <summary>
            Constructor. Initialises the Vector time stamp to [0].
            </summary>
            <param name="owner">The owner of the timestamp</param>
        </member>
        <member name="M:GCT.Protocols.VectorTimeStamp.getLocalTimeStamp">
            <summary>
            Returns the number of messages sent by the owner
            </summary>
            <returns>The number of messages sent by the owner</returns>
        </member>
        <member name="M:GCT.Protocols.VectorTimeStamp.increment">
            <summary>
            Increments the owners count by 1
            </summary>
        </member>
        <member name="M:GCT.Protocols.VectorTimeStamp.getTransportableVectorTimeStamp">
            <summary>
            Returns a representation of the object in a smaller transportable form.
            </summary>
            <returns>A representation of the object in a smaller transportable form.</returns>
        </member>
        <member name="M:GCT.Protocols.VectorTimeStamp.reset">
            <summary>
            Sets all the values equal to zero.
            </summary>
        </member>
        <member name="M:GCT.Protocols.VectorTimeStamp.max(GCT.Protocols.TransportableVectorTimeStamp)">
            <summary>
            Increases each value in the time stamp to the larger of either
            the current value or the corresponding value in the specified 
            time stamp.
            </summary>
            <param name="other">Time Stamp to compare to.</param>
        </member>
        <member name="M:GCT.Protocols.VectorTimeStamp.causallyNext(GCT.Protocols.TransportableVectorTimeStamp,System.String@)">
            <summary>
            Calculates if the value is causally next to the current value.
            </summary>
            <param name="other"></param>
            <param name="diag"></param>
            <returns></returns>
        </member>
        <member name="M:GCT.Protocols.VectorTimeStamp.merge(System.Collections.ArrayList)">
            <summary>
            Any members not present already will be added to the time stamp vector.
            </summary>
            <param name="newMembers"></param>
        </member>
        <member name="P:GCT.Protocols.VectorTimeStamp.Members">
            <summary>
            Gets the current members in the vector time stamp
            </summary>
        </member>
        <member name="P:GCT.Protocols.VectorTimeStamp.Values">
            <summary>
            Gets the current values in the vector time stamp
            </summary>
        </member>
        <member name="T:GCT.Protocols.VERIFY_SUSPECT">
            <remarks>
            Verifies that the suspected member is really dead. If yes,
            passes SUSPECT event up the stack, otherwise discards it. Has to be placed somewhere above the FD layer and
            below the GMS layer (receiver of the SUSPECT event).
            </remarks>
            <summary>
            Protocol: Verifies SUSPECT events traveling up the stack.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.VERIFY_SUSPECT.local_addr">
            <summary>Local Address</summary>
        </member>
        <member name="F:GCT.Protocols.VERIFY_SUSPECT.timeout">
            <summary>Number of millisecs to wait for an <i>i-am-not-dead</i> msg</summary>
        </member>
        <member name="F:GCT.Protocols.VERIFY_SUSPECT.num_msgs">
            <summary>Number of <i>are-you-alive</i> msgs and <i>i-am-not-dead</i> responses</summary>
        </member>
        <member name="F:GCT.Protocols.VERIFY_SUSPECT.suspects">
            <summary>Collection of current supsects and time (ms) since suspected</summary>
        </member>
        <member name="F:GCT.Protocols.VERIFY_SUSPECT.timer">
            <summary>Suspects members that havent responded by the timeout</summary>
        </member>
        <member name="M:GCT.Protocols.VERIFY_SUSPECT.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:GCT.Protocols.VERIFY_SUSPECT.getName">
            <summary>
            Returns unique protocol name
            </summary>
            <returns>Unique protocol name</returns>
        </member>
        <member name="M:GCT.Protocols.VERIFY_SUSPECT.setProperties(System.Data.PropertyCollection)">
            <summary>
            Sets the properties specified in the configuration string
            </summary>
            <param name="props">Properties to set</param>
            <returns>False if properties were specified that are not know, otherwise true</returns>
        </member>
        <member name="M:GCT.Protocols.VERIFY_SUSPECT.up(GCT.Event)">
            <summary>
            Processes <c>Events</c> travelling up the stack
            </summary>
            <param name="evt">The Event to be processed</param>
        </member>
        <member name="M:GCT.Protocols.VERIFY_SUSPECT.run">
            <remarks>
            Will be started when a suspect is added to the suspects hashtable. Continually iterates over the
            entries and removes entries whose time have elapsed. For each removed entry, a SUSPECT event is passed
            up the stack (because elapsed time means verification of member's liveness failed). Computes the shortest
            time to wait (min of all timeouts) and waits(time) msecs. Will be woken up when entry is removed (in case
            of successful verification of that member's liveness). Terminates when no entry remains in the hashtable.
            </remarks>
            <summary>
            Executed in a seperate Thread. Suspects members that haven't responded with <i>i-am-not-dead</i> by the timeout
            </summary>
        </member>
        <member name="M:GCT.Protocols.VERIFY_SUSPECT.suspect(GCT.Address)">
            <summary>
            Sends ARE_YOU_DEAD message to suspected_mbr, wait for return or timeout
            </summary>
            <param name="mbr">Suspected member</param>
        </member>
        <member name="M:GCT.Protocols.VERIFY_SUSPECT.unsuspect(GCT.Address)">
            <summary>
            Unsuspects reponding member
            </summary>
            <param name="mbr">Reponding member</param>
        </member>
        <member name="M:GCT.Protocols.VERIFY_SUSPECT.startTimer">
            <summary>
            Starts the timer, <c>run()</c>, to wait for responses
            </summary>
        </member>
        <member name="M:GCT.Protocols.VERIFY_SUSPECT.stop">
            <summary>
            Stops the timer, <c>run()</c>.
            </summary>
        </member>
        <member name="T:GCT.Protocols.VerifyHeader">
            <summary>
            VERIFY_SUSPECT Header
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.Protocols.VerifyHeader.ARE_YOU_DEAD">
            <summary>Header Type: Request</summary>
        </member>
        <member name="F:GCT.Protocols.VerifyHeader.I_AM_NOT_DEAD">
            <summary>Header Type: Response</summary>
        </member>
        <member name="F:GCT.Protocols.VerifyHeader.type">
            <summary>Header Type</summary>
        </member>
        <member name="F:GCT.Protocols.VerifyHeader.from">
            <summary>Address of the message sender</summary>
        </member>
        <member name="M:GCT.Protocols.VerifyHeader.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="type">Header type</param>
        </member>
        <member name="M:GCT.Protocols.VerifyHeader.#ctor(System.Int32,GCT.Address)">
            <summary>
            Constructor
            </summary>
            <param name="type">Header type</param>
            <param name="from">Address of the message sender</param>
        </member>
        <member name="M:GCT.Protocols.VerifyHeader.toString">
            <summary>
            String representation of the Header
            </summary>
            <returns>String representation of the Header</returns>
        </member>
        <member name="M:GCT.Protocols.VerifyHeader.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialises the information
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="context">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="M:GCT.Protocols.VerifyHeader.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor: Deserialises the information and recreates the instance.
            </summary>
            <param name="info">Standard <c>SerializationInfo</c> object</param>
            <param name="ctxt">Standard <c>StreamingContext</c> object</param>
        </member>
        <member name="T:GCT.View">
            <summary>
            Represents the current 'View' of the members of the group
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.View.vid">
            <remarks>
            The view id contains the creator address and a lamport time.
            the lamport time is the highest timestamp seen or sent from a view.
            if a view change comes in with a lower lamport time, the event is discarded.
            </remarks>
            <summary>
            A view is uniquely identified by its ViewID
            </summary>
        </member>
        <member name="F:GCT.View.members">
            <remarks>
            This list is always ordered, with the coordinator being the first member.
            the second member will be the new coordinator if the current one disappears
            or leaves the group.
            </remarks>
            <summary>
            A list containing all the members of the view
            </summary>
        </member>
        <member name="M:GCT.View.#ctor(GCT.ViewId,System.Collections.ArrayList)">
            <summary>
            Constructor
            </summary>
            <param name="vid">The view id of this view (can not be null)</param>
            <param name="members">Contains a list of all the members in the view, can be empty but not null.</param>
        </member>
        <member name="M:GCT.View.#ctor(GCT.Address,System.Int64,System.Collections.ArrayList)">
            <summary>
            Constructor
            </summary>
            <param name="creator">The creator of this view</param>
            <param name="id">The lamport timestamp of this view</param>
            <param name="members">Contains a list of all the members in the view, can be empty but not null.</param>
        </member>
        <member name="M:GCT.View.getVid">
            <summary>
            Returns the view ID of this view
            </summary>
            <returns>The view ID of this view</returns>
        </member>
        <member name="M:GCT.View.getCreator">
            <summary>
            Returns the creator of this view
            </summary>
            <returns>The creator of this view</returns>
        </member>
        <member name="M:GCT.View.getMembers">
            <remarks>
            Do NOT change this list, hence your will invalidate the view
            Make a copy if you have to modify it.
            </remarks>
            <summary>
            Returns a reference to the List of members (ordered)
            </summary>
            <returns></returns>
        </member>
        <member name="M:GCT.View.containsMember(GCT.Address)">
            <summary>
            Returns true, if this view contains a certain member
            </summary>
            <param name="mbr">The address of the member</param>
            <returns>True, if this view contains a certain member</returns>
        </member>
        <member name="M:GCT.View.size">
            <summary>
            Returns the number of members in this view
            </summary>
            <returns>The number of members in this view</returns>
        </member>
        <member name="M:GCT.View.ToString">
            <summary>
            Returns a string representation of the View
            </summary>
            <returns>A string representation of the View</returns>
        </member>
        <member name="M:GCT.View.copy">
            <summary>
            Copys the View
            </summary>
            <returns>A copy of the View</returns>
        </member>
        <member name="T:GCT.ViewId">
            <summary>
            Identificator used to tell which View is first.
            <p><b>Author:</b> Chris Koiak, Bela Ban</p>
            <p><b>Date:</b>  12/03/2003</p>
            </summary>
        </member>
        <member name="F:GCT.ViewId.coord_addr">
            <summary>Address of the issuer of this view</summary>
        </member>
        <member name="F:GCT.ViewId.id">
            <summary>Lamport time of the view</summary>
        </member>
        <member name="M:GCT.ViewId.#ctor(GCT.Address)">
            <remarks>
            Creates a ViewID with the coordinator address and a Lamport timestamp of 0.
            </remarks>
            <summary>
            Constructor
            </summary>
            <param name="coord_addr">The address of the member that issued this view</param>
        </member>
        <member name="M:GCT.ViewId.#ctor(GCT.Address,System.Int64)">
            <remarks>
            Creates a ViewID with the coordinator address and the given Lamport timestamp.
            </remarks>
            <summary>
            Constructor
            </summary>
            <param name="coord_addr">The address of the member that issued this view</param>
            <param name="id">The Lamport timestamp of the view</param>
        </member>
        <member name="M:GCT.ViewId.getId">
            <summary>
            Returns the lamport time of the view
            </summary>
            <returns>The lamport time of the view</returns>
        </member>
        <member name="M:GCT.ViewId.getCoordAddress">
            <summary>
            Returns the address of the member that issued this view
            </summary>
            <returns>The address of the member that issued this view</returns>
        </member>
        <member name="M:GCT.ViewId.ToString">
            <summary>
            Returns a string representation of the ViewId
            </summary>
            <returns>A string representation of the ViewId</returns>
        </member>
        <member name="M:GCT.ViewId.CompareTo(System.Object)">
            <summary>
            Establishes an order between 2 ViewIds. First compare on id. <em>Compare on coord_addr
            only if necessary</em> (i.e. ids are equal) !
            </summary>
            <param name="other">Second ViewId to compare to</param>
            <returns>0 for equality, value less than 0 if smaller, greater than 0 if greater.</returns>
        </member>
        <member name="M:GCT.ViewId.Equals(System.Object)">
            <summary>
            Determines if two ViewIds are equal
            </summary>
            <param name="other_view">Second ViewId to compare to</param>
            <returns>True if ViewIds are equal</returns>
        </member>
        <member name="M:GCT.ViewId.GetHashCode">
            <summary>
            Returns the hascode of the ViewId
            </summary>
            <returns>The hascode of the ViewId</returns>
        </member>
        <member name="M:GCT.ViewId.Copy">
            <summary>
            Returns a copy of the ViewId
            </summary>
            <returns>A copy of the ViewId</returns>
        </member>
    </members>
</doc>
